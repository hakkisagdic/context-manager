Directory structure:
└── vadimdemedes-ink/
    ├── license
    ├── package.json
    ├── tsconfig.json
    ├── .editorconfig
    ├── .npmrc
    ├── benchmark/
    │   ├── simple/
    │   │   ├── index.ts
    │   │   └── simple.tsx
    │   └── static/
    │       ├── index.ts
    │       └── static.tsx
    ├── examples/
    │   ├── aria/
    │   │   ├── aria.tsx
    │   │   └── index.ts
    │   ├── borders/
    │   │   ├── borders.tsx
    │   │   └── index.ts
    │   ├── box-backgrounds/
    │   │   ├── box-backgrounds.tsx
    │   │   └── index.ts
    │   ├── chat/
    │   │   ├── chat.tsx
    │   │   └── index.ts
    │   ├── counter/
    │   │   ├── counter.tsx
    │   │   └── index.ts
    │   ├── jest/
    │   │   ├── index.ts
    │   │   ├── jest.tsx
    │   │   ├── summary.tsx
    │   │   └── test.tsx
    │   ├── justify-content/
    │   │   ├── index.ts
    │   │   └── justify-content.tsx
    │   ├── render-throttle/
    │   │   └── index.tsx
    │   ├── select-input/
    │   │   ├── index.ts
    │   │   └── select-input.tsx
    │   ├── static/
    │   │   ├── index.ts
    │   │   └── static.tsx
    │   ├── subprocess-output/
    │   │   ├── index.ts
    │   │   └── subprocess-output.tsx
    │   ├── suspense/
    │   │   ├── index.ts
    │   │   └── suspense.tsx
    │   ├── table/
    │   │   ├── index.ts
    │   │   └── table.tsx
    │   ├── use-focus/
    │   │   ├── index.ts
    │   │   └── use-focus.tsx
    │   ├── use-focus-with-id/
    │   │   ├── index.ts
    │   │   └── use-focus-with-id.tsx
    │   ├── use-input/
    │   │   ├── index.ts
    │   │   └── use-input.tsx
    │   ├── use-stderr/
    │   │   ├── index.ts
    │   │   └── use-stderr.tsx
    │   └── use-stdout/
    │       ├── index.ts
    │       └── use-stdout.tsx
    ├── media/
    │   └── demo.js
    ├── src/
    │   ├── colorize.ts
    │   ├── devtools-window-polyfill.ts
    │   ├── devtools.ts
    │   ├── dom.ts
    │   ├── get-max-width.ts
    │   ├── global.d.ts
    │   ├── index.ts
    │   ├── ink.tsx
    │   ├── instances.ts
    │   ├── log-update.ts
    │   ├── measure-element.ts
    │   ├── measure-text.ts
    │   ├── output.ts
    │   ├── parse-keypress.ts
    │   ├── reconciler.ts
    │   ├── render-background.ts
    │   ├── render-border.ts
    │   ├── render-node-to-output.ts
    │   ├── render.ts
    │   ├── renderer.ts
    │   ├── squash-text-nodes.ts
    │   ├── styles.ts
    │   ├── wrap-text.ts
    │   ├── components/
    │   │   ├── AccessibilityContext.ts
    │   │   ├── App.tsx
    │   │   ├── AppContext.ts
    │   │   ├── BackgroundContext.ts
    │   │   ├── Box.tsx
    │   │   ├── ErrorOverview.tsx
    │   │   ├── FocusContext.ts
    │   │   ├── Newline.tsx
    │   │   ├── Spacer.tsx
    │   │   ├── Static.tsx
    │   │   ├── StderrContext.ts
    │   │   ├── StdinContext.ts
    │   │   ├── StdoutContext.ts
    │   │   ├── Text.tsx
    │   │   └── Transform.tsx
    │   └── hooks/
    │       ├── use-app.ts
    │       ├── use-focus-manager.ts
    │       ├── use-focus.ts
    │       ├── use-input.ts
    │       ├── use-is-screen-reader-enabled.ts
    │       ├── use-stderr.ts
    │       ├── use-stdin.ts
    │       └── use-stdout.ts
    ├── test/
    │   ├── background.tsx
    │   ├── borders.tsx
    │   ├── components.tsx
    │   ├── display.tsx
    │   ├── errors.tsx
    │   ├── exit.tsx
    │   ├── flex-align-items.tsx
    │   ├── flex-align-self.tsx
    │   ├── flex-direction.tsx
    │   ├── flex-justify-content.tsx
    │   ├── flex-wrap.tsx
    │   ├── flex.tsx
    │   ├── focus.tsx
    │   ├── gap.tsx
    │   ├── hooks.tsx
    │   ├── margin.tsx
    │   ├── measure-element.tsx
    │   ├── measure-text.tsx
    │   ├── overflow.tsx
    │   ├── padding.tsx
    │   ├── reconciler.tsx
    │   ├── render.tsx
    │   ├── screen-reader.tsx
    │   ├── text-width.tsx
    │   ├── text.tsx
    │   ├── tsconfig.json
    │   ├── width-height.tsx
    │   ├── fixtures/
    │   │   ├── ci.tsx
    │   │   ├── clear.tsx
    │   │   ├── console.tsx
    │   │   ├── erase-with-state-change.tsx
    │   │   ├── erase-with-static.tsx
    │   │   ├── erase.tsx
    │   │   ├── exit-double-raw-mode.tsx
    │   │   ├── exit-normally.tsx
    │   │   ├── exit-on-exit-with-error.tsx
    │   │   ├── exit-on-exit.tsx
    │   │   ├── exit-on-finish.tsx
    │   │   ├── exit-on-unmount.tsx
    │   │   ├── exit-raw-on-exit-with-error.tsx
    │   │   ├── exit-raw-on-exit.tsx
    │   │   ├── exit-raw-on-unmount.tsx
    │   │   ├── exit-with-thrown-error.tsx
    │   │   ├── fullscreen-no-extra-newline.tsx
    │   │   ├── use-input-ctrl-c.tsx
    │   │   ├── use-input-multiple.tsx
    │   │   ├── use-input.tsx
    │   │   └── use-stdout.tsx
    │   └── helpers/
    │       ├── create-stdout.ts
    │       ├── force-colors.ts
    │       ├── render-to-string.ts
    │       └── run.ts
    └── .github/
        └── workflows/
            └── test.yml

================================================
FILE: license
================================================
MIT License

Copyright (c) Vadym Demedes <vadimdemedes@hey.com> (github.com/vadimdemedes)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
FILE: package.json
================================================
{
	"name": "ink",
	"version": "6.4.0",
	"description": "React for CLI",
	"license": "MIT",
	"repository": "vadimdemedes/ink",
	"author": {
		"name": "Vadim Demedes",
		"email": "vadimdemedes@hey.com",
		"url": "https://github.com/vadimdemedes"
	},
	"type": "module",
	"exports": {
		"types": "./build/index.d.ts",
		"default": "./build/index.js"
	},
	"engines": {
		"node": ">=20"
	},
	"scripts": {
		"dev": "tsc --watch",
		"build": "tsc",
		"prepare": "npm run build",
		"test": "tsc --noEmit && xo && FORCE_COLOR=true ava",
		"example": "NODE_NO_WARNINGS=1 node --loader ts-node/esm",
		"benchmark": "NODE_NO_WARNINGS=1 node --loader ts-node/esm"
	},
	"files": [
		"build"
	],
	"keywords": [
		"react",
		"cli",
		"jsx",
		"stdout",
		"components",
		"command-line",
		"preact",
		"redux",
		"print",
		"render",
		"colors",
		"text"
	],
	"dependencies": {
		"@alcalzone/ansi-tokenize": "^0.2.1",
		"ansi-escapes": "^7.0.0",
		"ansi-styles": "^6.2.1",
		"auto-bind": "^5.0.1",
		"chalk": "^5.6.0",
		"cli-boxes": "^3.0.0",
		"cli-cursor": "^4.0.0",
		"cli-truncate": "^4.0.0",
		"code-excerpt": "^4.0.0",
		"es-toolkit": "^1.39.10",
		"indent-string": "^5.0.0",
		"is-in-ci": "^2.0.0",
		"patch-console": "^2.0.0",
		"react-reconciler": "^0.32.0",
		"signal-exit": "^3.0.7",
		"slice-ansi": "^7.1.0",
		"stack-utils": "^2.0.6",
		"string-width": "^7.2.0",
		"type-fest": "^4.27.0",
		"widest-line": "^5.0.0",
		"wrap-ansi": "^9.0.0",
		"ws": "^8.18.0",
		"yoga-layout": "~3.2.1"
	},
	"devDependencies": {
		"@faker-js/faker": "^9.8.0",
		"@sindresorhus/tsconfig": "^7.0.0",
		"@sinonjs/fake-timers": "^14.0.0",
		"@types/ms": "^2.1.0",
		"@types/node": "^22.15.24",
		"@types/react": "^19.1.5",
		"@types/react-reconciler": "^0.32.2",
		"@types/signal-exit": "^3.0.0",
		"@types/sinon": "^17.0.3",
		"@types/stack-utils": "^2.0.2",
		"@types/ws": "^8.18.1",
		"@vdemedes/prettier-config": "^2.0.1",
		"ava": "^5.1.1",
		"boxen": "^8.0.1",
		"delay": "^6.0.0",
		"eslint-config-xo-react": "0.27.0",
		"eslint-plugin-react": "^7.37.5",
		"eslint-plugin-react-hooks": "^5.0.0",
		"ms": "^2.1.3",
		"node-pty": "^1.0.0",
		"p-queue": "^8.0.0",
		"prettier": "^3.3.3",
		"react": "^19.1.0",
		"react-devtools-core": "^6.1.2",
		"sinon": "^20.0.0",
		"strip-ansi": "^7.1.0",
		"ts-node": "^10.9.2",
		"typescript": "^5.8.3",
		"xo": "^0.59.3"
	},
	"peerDependencies": {
		"@types/react": ">=19.0.0",
		"react": ">=19.0.0",
		"react-devtools-core": "^6.1.2"
	},
	"peerDependenciesMeta": {
		"@types/react": {
			"optional": true
		},
		"react-devtools-core": {
			"optional": true
		}
	},
	"ava": {
		"workerThreads": false,
		"files": [
			"test/**/*",
			"!test/helpers/**/*",
			"!test/fixtures/**/*"
		],
		"extensions": {
			"ts": "module",
			"tsx": "module"
		},
		"nodeArguments": [
			"--loader=ts-node/esm"
		]
	},
	"xo": {
		"extends": [
			"xo-react"
		],
		"plugins": [
			"react"
		],
		"prettier": true,
		"rules": {
			"react/no-unescaped-entities": "off",
			"react/state-in-constructor": "off",
			"react/jsx-indent": "off",
			"react/prop-types": "off",
			"unicorn/import-index": "off",
			"import/no-useless-path-segments": "off",
			"react-hooks/exhaustive-deps": "off",
			"complexity": "off"
		},
		"ignores": [
			"src/parse-keypress.ts"
		],
		"overrides": [
			{
				"files": [
					"src/**/*.{ts,tsx}",
					"test/**/*.{ts,tsx}"
				],
				"rules": {
					"no-unused-expressions": "off",
					"camelcase": [
						"error",
						{
							"allow": [
								"^unstable__",
								"^internal_"
							]
						}
					],
					"unicorn/filename-case": "off",
					"react/default-props-match-prop-types": "off",
					"unicorn/prevent-abbreviations": "off",
					"react/require-default-props": "off",
					"react/jsx-curly-brace-presence": "off",
					"@typescript-eslint/no-empty-function": "off",
					"@typescript-eslint/promise-function-async": "warn",
					"@typescript-eslint/explicit-function-return": "off",
					"@typescript-eslint/explicit-function-return-type": "off",
					"dot-notation": "off",
					"react/boolean-prop-naming": "off",
					"unicorn/prefer-dom-node-remove": "off",
					"unicorn/prefer-event-target": "off"
				}
			},
			{
				"files": [
					"examples/**/*.{ts,tsx}",
					"benchmark/**/*.{ts,tsx}"
				],
				"rules": {
					"import/no-unassigned-import": "off"
				}
			}
		]
	},
	"prettier": "@vdemedes/prettier-config"
}



================================================
FILE: tsconfig.json
================================================
{
	"extends": "@sindresorhus/tsconfig",
	"compilerOptions": {
		"outDir": "build",
		"lib": [
			"DOM",
			"DOM.Iterable",
			"ES2023"
		],
		"sourceMap": true,
		"jsx": "react",
		"isolatedModules": true
	},
	"include": ["src"],
	"ts-node": {
		"transpileOnly": true,
		"files": true,
		"experimentalResolver": true,
		"experimentalSpecifierResolution": "node"
	}
}



================================================
FILE: .editorconfig
================================================
root = true

[*]
indent_style = tab
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.yml]
indent_style = space
indent_size = 2



================================================
FILE: .npmrc
================================================
package-lock=false



================================================
FILE: benchmark/simple/index.ts
================================================
import './simple.js';



================================================
FILE: benchmark/simple/simple.tsx
================================================
import React from 'react';
import {render, Box, Text} from '../../src/index.js';

function App() {
	return (
		<Box flexDirection="column" padding={1}>
			<Text underline bold color="red">
				{/* eslint-disable-next-line react/jsx-curly-brace-presence */}
				{'Hello World'}
			</Text>

			<Box marginTop={1} width={60}>
				<Text>
					Cupcake ipsum dolor sit amet candy candy. Sesame snaps cookie I love
					tootsie roll apple pie bonbon wafer. Caramels sesame snaps icing
					cotton candy I love cookie sweet roll. I love bonbon sweet.
				</Text>
			</Box>

			<Box marginTop={1} flexDirection="column">
				<Text backgroundColor="white" color="black">
					Colors:
				</Text>

				<Box flexDirection="column" paddingLeft={1}>
					<Text>
						- <Text color="red">Red</Text>
					</Text>
					<Text>
						- <Text color="blue">Blue</Text>
					</Text>
					<Text>
						- <Text color="green">Green</Text>
					</Text>
				</Box>
			</Box>
		</Box>
	);
}

const {rerender} = render(<App />);

for (let index = 0; index < 100_000; index++) {
	rerender(<App />);
}



================================================
FILE: benchmark/static/index.ts
================================================
import './static.js';



================================================
FILE: benchmark/static/static.tsx
================================================
import React from 'react';
import {render, Box, Text, Static} from '../../src/index.js';

function App() {
	const [items, setItems] = React.useState<
		Array<{
			id: number;
		}>
	>([]);
	const itemCountReference = React.useRef(0);

	React.useEffect(() => {
		let timer: NodeJS.Timeout | undefined;

		const run = () => {
			if (itemCountReference.current++ > 1000) {
				return;
			}

			setItems(previousItems => [
				...previousItems,
				{
					id: previousItems.length,
				},
			]);

			timer = setTimeout(run, 10);
		};

		run();

		return () => {
			clearTimeout(timer);
		};
	}, []);

	return (
		<Box flexDirection="column">
			<Static items={items}>
				{(item, index) => (
					<Box key={item.id} padding={1} flexDirection="column">
						<Text color="green">Item #{index}</Text>
						<Text>Item content</Text>
					</Box>
				)}
			</Static>

			<Box flexDirection="column" padding={1}>
				<Text underline bold color="red">
					{/* eslint-disable-next-line react/jsx-curly-brace-presence */}
					{'Hello World'}
				</Text>

				<Text>Rendered: {items.length}</Text>

				<Box marginTop={1} width={60}>
					<Text>
						Cupcake ipsum dolor sit amet candy candy. Sesame snaps cookie I love
						tootsie roll apple pie bonbon wafer. Caramels sesame snaps icing
						cotton candy I love cookie sweet roll. I love bonbon sweet.
					</Text>
				</Box>

				<Box marginTop={1} flexDirection="column">
					<Text backgroundColor="white" color="black">
						Colors:
					</Text>

					<Box flexDirection="column" paddingLeft={1}>
						<Text>
							- <Text color="red">Red</Text>
						</Text>
						<Text>
							- <Text color="blue">Blue</Text>
						</Text>
						<Text>
							- <Text color="green">Green</Text>
						</Text>
					</Box>
				</Box>
			</Box>
		</Box>
	);
}

render(<App />);



================================================
FILE: examples/aria/aria.tsx
================================================
import React, {useState} from 'react';
import {render, Text, Box, useInput} from '../../src/index.js';

function AriaExample() {
	const [checked, setChecked] = useState(false);

	useInput(key => {
		if (key === ' ') {
			setChecked(!checked);
		}
	});

	return (
		<Box flexDirection="column">
			<Text>
				Press spacebar to toggle the checkbox. This example is best experienced
				with a screen reader.
			</Text>
			<Box marginTop={1}>
				<Box aria-role="checkbox" aria-state={{checked}}>
					<Text>{checked ? '[x]' : '[ ]'}</Text>
				</Box>
			</Box>
			<Box marginTop={1}>
				<Text aria-hidden="true">This text is hidden from screen readers.</Text>
			</Box>
		</Box>
	);
}

render(<AriaExample />);



================================================
FILE: examples/aria/index.ts
================================================
import './aria.js';



================================================
FILE: examples/borders/borders.tsx
================================================
import React from 'react';
import {render, Box, Text} from '../../src/index.js';

function Borders() {
	return (
		<Box flexDirection="column" padding={2}>
			<Box>
				<Box borderStyle="single" marginRight={2}>
					<Text>single</Text>
				</Box>

				<Box borderStyle="double" marginRight={2}>
					<Text>double</Text>
				</Box>

				<Box borderStyle="round" marginRight={2}>
					<Text>round</Text>
				</Box>

				<Box borderStyle="bold">
					<Text>bold</Text>
				</Box>
			</Box>

			<Box marginTop={1}>
				<Box borderStyle="singleDouble" marginRight={2}>
					<Text>singleDouble</Text>
				</Box>

				<Box borderStyle="doubleSingle" marginRight={2}>
					<Text>doubleSingle</Text>
				</Box>

				<Box borderStyle="classic">
					<Text>classic</Text>
				</Box>
			</Box>
		</Box>
	);
}

render(<Borders />);



================================================
FILE: examples/borders/index.ts
================================================
import './borders.js';



================================================
FILE: examples/box-backgrounds/box-backgrounds.tsx
================================================
import React from 'react';
import {Box, Text} from '../../src/index.js';

function BoxBackgrounds() {
	return (
		<Box flexDirection="column" gap={1}>
			<Text bold>Box Background Examples:</Text>

			<Box>
				<Text>1. Standard red background (10x3):</Text>
			</Box>
			<Box backgroundColor="red" width={10} height={3} alignSelf="flex-start">
				<Text>Hello</Text>
			</Box>

			<Box>
				<Text>2. Blue background with border (12x4):</Text>
			</Box>
			<Box
				backgroundColor="blue"
				borderStyle="round"
				width={12}
				height={4}
				alignSelf="flex-start"
			>
				<Text>Border</Text>
			</Box>

			<Box>
				<Text>3. Green background with padding (14x4):</Text>
			</Box>
			<Box
				backgroundColor="green"
				padding={1}
				width={14}
				height={4}
				alignSelf="flex-start"
			>
				<Text>Padding</Text>
			</Box>

			<Box>
				<Text>4. Yellow background with center alignment (16x3):</Text>
			</Box>
			<Box
				backgroundColor="yellow"
				width={16}
				height={3}
				justifyContent="center"
				alignSelf="flex-start"
			>
				<Text>Centered</Text>
			</Box>

			<Box>
				<Text>5. Magenta background, column layout (12x5):</Text>
			</Box>
			<Box
				backgroundColor="magenta"
				flexDirection="column"
				width={12}
				height={5}
				alignSelf="flex-start"
			>
				<Text>Line 1</Text>
				<Text>Line 2</Text>
			</Box>

			<Box>
				<Text>6. Hex color background #FF8800 (10x3):</Text>
			</Box>
			<Box
				backgroundColor="#FF8800"
				width={10}
				height={3}
				alignSelf="flex-start"
			>
				<Text>Hex</Text>
			</Box>

			<Box>
				<Text>7. RGB background rgb(0,255,0) (10x3):</Text>
			</Box>
			<Box
				backgroundColor="rgb(0,255,0)"
				width={10}
				height={3}
				alignSelf="flex-start"
			>
				<Text>RGB</Text>
			</Box>

			<Box>
				<Text>8. Text inheritance test:</Text>
			</Box>
			<Box backgroundColor="cyan" alignSelf="flex-start">
				<Text>Inherited </Text>
				<Text backgroundColor="red">Override </Text>
				<Text>Back to inherited</Text>
			</Box>

			<Box>
				<Text>9. Nested background inheritance:</Text>
			</Box>
			<Box backgroundColor="blue" alignSelf="flex-start">
				<Text>Outer: </Text>
				<Box backgroundColor="yellow">
					<Text>Inner: </Text>
					<Text backgroundColor="red">Deep</Text>
				</Box>
			</Box>

			<Box marginTop={1}>
				<Text>Press Ctrl+C to exit</Text>
			</Box>
		</Box>
	);
}

export default BoxBackgrounds;



================================================
FILE: examples/box-backgrounds/index.ts
================================================
#!/usr/bin/env node
import React from 'react';
import {render} from '../../src/index.js';
import BoxBackgrounds from './box-backgrounds.js';

render(React.createElement(BoxBackgrounds));



================================================
FILE: examples/chat/chat.tsx
================================================
import React, {useState} from 'react';
import {render, Text, Box, useInput} from '../../src/index.js';

let messageId = 0;

function ChatApp() {
	const [input, setInput] = useState('');

	const [messages, setMessages] = useState<
		Array<{
			id: number;
			text: string;
		}>
	>([]);

	useInput((character, key) => {
		if (key.return) {
			if (input) {
				setMessages(previousMessages => [
					...previousMessages,
					{
						id: messageId++,
						text: `User: ${input}`,
					},
				]);
				setInput('');
			}
		} else if (key.backspace || key.delete) {
			setInput(currentInput => currentInput.slice(0, -1));
		} else {
			setInput(currentInput => currentInput + character);
		}
	});

	return (
		<Box flexDirection="column" padding={1}>
			<Box flexDirection="column">
				{messages.map(message => (
					<Text key={message.id}>{message.text}</Text>
				))}
			</Box>

			<Box marginTop={1}>
				<Text>Enter your message: {input}</Text>
			</Box>
		</Box>
	);
}

render(<ChatApp />);



================================================
FILE: examples/chat/index.ts
================================================
import './chat.js';



================================================
FILE: examples/counter/counter.tsx
================================================
import React from 'react';
import {render, Text} from '../../src/index.js';

function Counter() {
	const [counter, setCounter] = React.useState(0);

	React.useEffect(() => {
		const timer = setInterval(() => {
			setCounter(prevCounter => prevCounter + 1); // eslint-disable-line unicorn/prevent-abbreviations
		}, 100);

		return () => {
			clearInterval(timer);
		};
	}, []);

	return <Text color="green">{counter} tests passed</Text>;
}

render(<Counter />);



================================================
FILE: examples/counter/index.ts
================================================
import './counter.js';



================================================
FILE: examples/jest/index.ts
================================================
import './jest.js';



================================================
FILE: examples/jest/jest.tsx
================================================
import React from 'react';
import PQueue from 'p-queue';
import delay from 'delay';
import ms from 'ms';
import {Static, Box, render} from '../../src/index.js';
import Summary from './summary.jsx';
import Test from './test.js';

const paths = [
	'tests/login.js',
	'tests/signup.js',
	'tests/forgot-password.js',
	'tests/reset-password.js',
	'tests/view-profile.js',
	'tests/edit-profile.js',
	'tests/delete-profile.js',
	'tests/posts.js',
	'tests/post.js',
	'tests/comments.js',
];

type State = {
	startTime: number;
	completedTests: Array<{
		path: string;
		status: string;
	}>;
	runningTests: Array<{
		path: string;
		status: string;
	}>;
};

class Jest extends React.Component<Record<string, unknown>, State> {
	constructor(properties: Record<string, unknown>) {
		super(properties);

		this.state = {
			startTime: Date.now(),
			completedTests: [],
			runningTests: [],
		};
	}

	render() {
		const {startTime, completedTests, runningTests} = this.state;

		return (
			<Box flexDirection="column">
				<Static items={completedTests}>
					{test => (
						<Test key={test.path} status={test.status} path={test.path} />
					)}
				</Static>

				{runningTests.length > 0 && (
					<Box flexDirection="column" marginTop={1}>
						{runningTests.map(test => (
							<Test key={test.path} status={test.status} path={test.path} />
						))}
					</Box>
				)}

				<Summary
					isFinished={runningTests.length === 0}
					passed={completedTests.filter(test => test.status === 'pass').length}
					failed={completedTests.filter(test => test.status === 'fail').length}
					time={ms(Date.now() - startTime)}
				/>
			</Box>
		);
	}

	componentDidMount() {
		const queue = new PQueue({concurrency: 4});

		for (const path of paths) {
			void queue.add(this.runTest.bind(this, path));
		}
	}

	async runTest(path: string) {
		this.setState(previousState => ({
			runningTests: [
				...previousState.runningTests,
				{
					status: 'runs',
					path,
				},
			],
		}));

		await delay(1000 * Math.random());

		this.setState(previousState => ({
			runningTests: previousState.runningTests.filter(
				test => test.path !== path,
			),
			completedTests: [
				...previousState.completedTests,
				{
					status: Math.random() < 0.5 ? 'pass' : 'fail',
					path,
				},
			],
		}));
	}
}

render(<Jest />);



================================================
FILE: examples/jest/summary.tsx
================================================
import React from 'react';
import {Box, Text} from '../../src/index.js';

type Properties = {
	readonly isFinished: boolean;
	readonly passed: number;
	readonly failed: number;
	readonly time: string;
};

function Summary({isFinished, passed, failed, time}: Properties) {
	return (
		<Box flexDirection="column" marginTop={1}>
			<Box>
				<Box width={14}>
					<Text bold>Test Suites:</Text>
				</Box>
				{failed > 0 && (
					<Text bold color="red">
						{failed} failed,{' '}
					</Text>
				)}
				{passed > 0 && (
					<Text bold color="green">
						{passed} passed,{' '}
					</Text>
				)}
				<Text>{passed + failed} total</Text>
			</Box>

			<Box>
				<Box width={14}>
					<Text bold>Time:</Text>
				</Box>

				<Text>{time}</Text>
			</Box>

			{isFinished && (
				<Box>
					<Text dimColor>Ran all test suites.</Text>
				</Box>
			)}
		</Box>
	);
}

export default Summary;



================================================
FILE: examples/jest/test.tsx
================================================
import React from 'react';
import {Box, Text} from '../../src/index.js';

const getBackgroundForStatus = (status: string): string | undefined => {
	switch (status) {
		case 'runs': {
			return 'yellow';
		}

		case 'pass': {
			return 'green';
		}

		case 'fail': {
			return 'red';
		}

		default: {
			return undefined;
		}
	}
};

type Properties = {
	readonly status: string;
	readonly path: string;
};

function Test({status, path}: Properties) {
	return (
		<Box>
			<Text color="black" backgroundColor={getBackgroundForStatus(status)}>
				{` ${status.toUpperCase()} `}
			</Text>

			<Box marginLeft={1}>
				<Text dimColor>{path.split('/')[0]}/</Text>

				<Text bold color="white">
					{path.split('/')[1]}
				</Text>
			</Box>
		</Box>
	);
}

export default Test;



================================================
FILE: examples/justify-content/index.ts
================================================
import './justify-content.js';



================================================
FILE: examples/justify-content/justify-content.tsx
================================================
import React from 'react';
import {render, Box, Text} from '../../src/index.js';

function JustifyContent() {
	return (
		<Box flexDirection="column">
			<Box>
				<Text>[</Text>
				<Box justifyContent="flex-start" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] flex-start</Text>
			</Box>
			<Box>
				<Text>[</Text>
				<Box justifyContent="flex-end" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] flex-end</Text>
			</Box>
			<Box>
				<Text>[</Text>
				<Box justifyContent="center" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] center</Text>
			</Box>
			<Box>
				<Text>[</Text>
				<Box justifyContent="space-around" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] space-around</Text>
			</Box>
			<Box>
				<Text>[</Text>
				<Box justifyContent="space-between" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] space-between</Text>
			</Box>
			<Box>
				<Text>[</Text>
				<Box justifyContent="space-evenly" width={20} height={1}>
					<Text>X</Text>
					<Text>Y</Text>
				</Box>
				<Text>] space-evenly</Text>
			</Box>
		</Box>
	);
}

render(<JustifyContent />);



================================================
FILE: examples/render-throttle/index.tsx
================================================
import React, {useState, useEffect} from 'react';
import {render, Box, Text} from '../../src/index.js';

function App() {
	const [count, setCount] = useState(0);

	useEffect(() => {
		const interval = setInterval(() => {
			setCount(c => c + 1);
		}, 10); // Update every 10ms

		return () => {
			clearInterval(interval);
		};
	}, []);

	return (
		<Box flexDirection="column" padding={1}>
			<Text>Counter: {count}</Text>
			<Text>This updates every 10ms but renders are throttled</Text>
			<Text>Press Ctrl+C to exit</Text>
		</Box>
	);
}

// Example with custom maxFps
render(<App />, {
	maxFps: 10, // Only render at 10fps (every ~100ms) instead of default 30fps
});



================================================
FILE: examples/select-input/index.ts
================================================
import './select-input.js';



================================================
FILE: examples/select-input/select-input.tsx
================================================
import React, {useState} from 'react';
import {
	render,
	Text,
	Box,
	useInput,
	useIsScreenReaderEnabled,
} from '../../src/index.js';

const items = ['Red', 'Green', 'Blue', 'Yellow', 'Magenta', 'Cyan'];

function SelectInput() {
	const [selectedIndex, setSelectedIndex] = useState(0);
	const isScreenReaderEnabled = useIsScreenReaderEnabled();

	useInput((input, key) => {
		if (key.upArrow) {
			setSelectedIndex(previousIndex =>
				previousIndex === 0 ? items.length - 1 : previousIndex - 1,
			);
		}

		if (key.downArrow) {
			setSelectedIndex(previousIndex =>
				previousIndex === items.length - 1 ? 0 : previousIndex + 1,
			);
		}

		if (isScreenReaderEnabled) {
			const number = Number.parseInt(input, 10);
			if (!Number.isNaN(number) && number > 0 && number <= items.length) {
				setSelectedIndex(number - 1);
			}
		}
	});

	return (
		<Box flexDirection="column" aria-role="list">
			<Text>Select a color:</Text>
			{items.map((item, index) => {
				const isSelected = index === selectedIndex;
				const label = isSelected ? `> ${item}` : `  ${item}`;
				const screenReaderLabel = `${index + 1}. ${item}`;

				return (
					<Box
						key={item}
						aria-role="listitem"
						aria-state={{selected: isSelected}}
						aria-label={isScreenReaderEnabled ? screenReaderLabel : undefined}
					>
						<Text color={isSelected ? 'blue' : undefined}>{label}</Text>
					</Box>
				);
			})}
		</Box>
	);
}

render(<SelectInput />);



================================================
FILE: examples/static/index.ts
================================================
import './static.js';



================================================
FILE: examples/static/static.tsx
================================================
import React from 'react';
import {Box, Text, render, Static} from '../../src/index.js';

function Example() {
	const [tests, setTests] = React.useState<
		Array<{
			id: number;
			title: string;
		}>
	>([]);

	React.useEffect(() => {
		let completedTests = 0;
		let timer: NodeJS.Timeout | undefined;

		const run = () => {
			if (completedTests++ < 10) {
				setTests(previousTests => [
					...previousTests,
					{
						id: previousTests.length,
						title: `Test #${previousTests.length + 1}`,
					},
				]);

				timer = setTimeout(run, 100);
			}
		};

		run();

		return () => {
			clearTimeout(timer);
		};
	}, []);

	return (
		<>
			<Static items={tests}>
				{test => (
					<Box key={test.id}>
						<Text color="green">✔ {test.title}</Text>
					</Box>
				)}
			</Static>

			<Box marginTop={1}>
				<Text dimColor>Completed tests: {tests.length}</Text>
			</Box>
		</>
	);
}

render(<Example />);



================================================
FILE: examples/subprocess-output/index.ts
================================================
import './subprocess-output.js';



================================================
FILE: examples/subprocess-output/subprocess-output.tsx
================================================
import childProcess from 'node:child_process';
import type Buffer from 'node:buffer';
import React from 'react';
import stripAnsi from 'strip-ansi';
import {render, Text, Box} from '../../src/index.js';

function SubprocessOutput() {
	const [output, setOutput] = React.useState('');

	React.useEffect(() => {
		const subProcess = childProcess.spawn('npm', [
			'run',
			'example',
			'examples/jest',
		]);

		// eslint-disable-next-line @typescript-eslint/ban-types
		subProcess.stdout.on('data', (newOutput: Buffer) => {
			const lines = stripAnsi(newOutput.toString('utf8')).split('\n');
			setOutput(lines.slice(-5).join('\n'));
		});
	}, [setOutput]);

	return (
		<Box flexDirection="column" padding={1}>
			<Text>Сommand output:</Text>
			<Box marginTop={1}>
				<Text>{output}</Text>
			</Box>
		</Box>
	);
}

render(<SubprocessOutput />);



================================================
FILE: examples/suspense/index.ts
================================================
import './suspense.js';



================================================
FILE: examples/suspense/suspense.tsx
================================================
import React from 'react';
import {render, Text} from '../../src/index.js';

let promise: Promise<void> | undefined;
let state: string | undefined;
let value: string | undefined;

const read = () => {
	if (!promise) {
		promise = new Promise(resolve => {
			setTimeout(resolve, 500);
		});

		state = 'pending';

		(async () => {
			await promise;
			state = 'done';
			value = 'Hello World';
		})();
	}

	if (state === 'pending') {
		// eslint-disable-next-line @typescript-eslint/only-throw-error
		throw promise;
	}

	if (state === 'done') {
		return value;
	}
};

function Example() {
	const message = read();
	return <Text>{message}</Text>;
}

function Fallback() {
	return <Text>Loading...</Text>;
}

render(
	<React.Suspense fallback={<Fallback />}>
		<Example />
	</React.Suspense>,
);



================================================
FILE: examples/table/index.ts
================================================
import './table.js';



================================================
FILE: examples/table/table.tsx
================================================
import React from 'react';
import {faker} from '@faker-js/faker';
import {Box, Text, render} from '../../src/index.js';

const users = Array.from({length: 10})
	.fill(true)
	.map((_, index) => ({
		id: index,
		name: faker.internet.username(),
		email: faker.internet.email(),
	}));

function Table() {
	return (
		<Box flexDirection="column" width={80}>
			<Box>
				<Box width="10%">
					<Text>ID</Text>
				</Box>

				<Box width="50%">
					<Text>Name</Text>
				</Box>

				<Box width="40%">
					<Text>Email</Text>
				</Box>
			</Box>

			{users.map(user => (
				<Box key={user.id}>
					<Box width="10%">
						<Text>{user.id}</Text>
					</Box>

					<Box width="50%">
						<Text>{user.name}</Text>
					</Box>

					<Box width="40%">
						<Text>{user.email}</Text>
					</Box>
				</Box>
			))}
		</Box>
	);
}

render(<Table />);



================================================
FILE: examples/use-focus/index.ts
================================================
import './use-focus.js';



================================================
FILE: examples/use-focus/use-focus.tsx
================================================
import React from 'react';
import {Box, Text, render, useFocus} from '../../src/index.js';

function Focus() {
	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text>
					Press Tab to focus next element, Shift+Tab to focus previous element,
					Esc to reset focus.
				</Text>
			</Box>
			<Item label="First" />
			<Item label="Second" />
			<Item label="Third" />
		</Box>
	);
}

function Item({label}) {
	const {isFocused} = useFocus();
	return (
		<Text>
			{label} {isFocused && <Text color="green">(focused)</Text>}
		</Text>
	);
}

render(<Focus />);



================================================
FILE: examples/use-focus-with-id/index.ts
================================================
import './use-focus-with-id.js';



================================================
FILE: examples/use-focus-with-id/use-focus-with-id.tsx
================================================
import React from 'react';
import {
	render,
	Box,
	Text,
	useFocus,
	useInput,
	useFocusManager,
} from '../../src/index.js';

function Focus() {
	const {focus} = useFocusManager();

	useInput(input => {
		if (input === '1') {
			focus('1');
		}

		if (input === '2') {
			focus('2');
		}

		if (input === '3') {
			focus('3');
		}
	});

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text>
					Press Tab to focus next element, Shift+Tab to focus previous element,
					Esc to reset focus.
				</Text>
			</Box>
			<Item id="1" label="Press 1 to focus" />
			<Item id="2" label="Press 2 to focus" />
			<Item id="3" label="Press 3 to focus" />
		</Box>
	);
}

type ItemProperties = {
	readonly id: number;
	readonly label: string;
};

function Item({label, id}: ItemProperties) {
	const {isFocused} = useFocus({id});

	return (
		<Text>
			{label} {isFocused && <Text color="green">(focused)</Text>}
		</Text>
	);
}

render(<Focus />);



================================================
FILE: examples/use-input/index.ts
================================================
import './use-input.js';



================================================
FILE: examples/use-input/use-input.tsx
================================================
import React from 'react';
import {render, useInput, useApp, Box, Text} from '../../src/index.js';

function Robot() {
	const {exit} = useApp();
	const [x, setX] = React.useState(1);
	const [y, setY] = React.useState(1);

	useInput((input, key) => {
		if (input === 'q') {
			exit();
		}

		if (key.leftArrow) {
			setX(Math.max(1, x - 1));
		}

		if (key.rightArrow) {
			setX(Math.min(20, x + 1));
		}

		if (key.upArrow) {
			setY(Math.max(1, y - 1));
		}

		if (key.downArrow) {
			setY(Math.min(10, y + 1));
		}
	});

	return (
		<Box flexDirection="column">
			<Text>Use arrow keys to move the face. Press “q” to exit.</Text>
			<Box height={12} paddingLeft={x} paddingTop={y}>
				<Text>^_^</Text>
			</Box>
		</Box>
	);
}

render(<Robot />);



================================================
FILE: examples/use-stderr/index.ts
================================================
import './use-stderr.js';



================================================
FILE: examples/use-stderr/use-stderr.tsx
================================================
import React from 'react';
import {render, Text, useStderr} from '../../src/index.js';

function Example() {
	const {write} = useStderr();

	React.useEffect(() => {
		const timer = setInterval(() => {
			write('Hello from Ink to stderr\n');
		}, 1000);

		return () => {
			clearInterval(timer);
		};
	}, []);

	return <Text>Hello World</Text>;
}

render(<Example />);



================================================
FILE: examples/use-stdout/index.ts
================================================
import './use-stdout.js';



================================================
FILE: examples/use-stdout/use-stdout.tsx
================================================
import React from 'react';
import {render, Box, Text, useStdout} from '../../src/index.js';

function Example() {
	const {stdout, write} = useStdout();

	React.useEffect(() => {
		const timer = setInterval(() => {
			write('Hello from Ink to stdout\n');
		}, 1000);

		return () => {
			clearInterval(timer);
		};
	}, []);

	return (
		<Box flexDirection="column" paddingX={2} paddingY={1}>
			<Text bold underline>
				Terminal dimensions:
			</Text>

			<Box marginTop={1}>
				<Text>
					Width: <Text bold>{stdout.columns}</Text>
				</Text>
			</Box>
			<Box>
				<Text>
					Height: <Text bold>{stdout.rows}</Text>
				</Text>
			</Box>
		</Box>
	);
}

render(<Example />);



================================================
FILE: media/demo.js
================================================
import process from 'node:process';
import React from 'react';
import {render, Box, Text} from 'ink';

class Counter extends React.PureComponent {
	constructor() {
		super();

		this.state = {
			i: 0,
		};
	}

	render() {
		return React.createElement(
			Box,
			{flexDirection: 'column'},
			React.createElement(
				Box,
				{},
				React.createElement(Text, {color: 'blue'}, '~/Projects/ink '),
			),
			React.createElement(
				Box,
				{},
				React.createElement(Text, {color: 'magenta'}, '❯ '),
				React.createElement(Text, {color: 'green'}, 'node '),
				React.createElement(Text, {}, 'media/example'),
			),
			React.createElement(
				Text,
				{color: 'green'},
				`${this.state.i} tests passed`,
			),
		);
	}

	componentDidMount() {
		this.timer = setInterval(() => {
			if (this.state.i === 50) {
				process.exit(0); // eslint-disable-line unicorn/no-process-exit
			}

			this.setState(previousState => ({
				i: previousState.i + 1,
			}));
		}, 100);
	}

	componentWillUnmount() {
		clearInterval(this.timer);
	}
}

render(React.createElement(Counter));



================================================
FILE: src/colorize.ts
================================================
import chalk, {type ForegroundColorName, type BackgroundColorName} from 'chalk';

type ColorType = 'foreground' | 'background';

const rgbRegex = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/;
const ansiRegex = /^ansi256\(\s?(\d+)\s?\)$/;

const isNamedColor = (color: string): color is ForegroundColorName => {
	return color in chalk;
};

const colorize = (
	str: string,
	color: string | undefined,
	type: ColorType,
): string => {
	if (!color) {
		return str;
	}

	if (isNamedColor(color)) {
		if (type === 'foreground') {
			return chalk[color](str);
		}

		const methodName = `bg${
			color[0]!.toUpperCase() + color.slice(1)
		}` as BackgroundColorName;

		return chalk[methodName](str);
	}

	if (color.startsWith('#')) {
		return type === 'foreground'
			? chalk.hex(color)(str)
			: chalk.bgHex(color)(str);
	}

	if (color.startsWith('ansi256')) {
		const matches = ansiRegex.exec(color);

		if (!matches) {
			return str;
		}

		const value = Number(matches[1]);

		return type === 'foreground'
			? chalk.ansi256(value)(str)
			: chalk.bgAnsi256(value)(str);
	}

	if (color.startsWith('rgb')) {
		const matches = rgbRegex.exec(color);

		if (!matches) {
			return str;
		}

		const firstValue = Number(matches[1]);
		const secondValue = Number(matches[2]);
		const thirdValue = Number(matches[3]);

		return type === 'foreground'
			? chalk.rgb(firstValue, secondValue, thirdValue)(str)
			: chalk.bgRgb(firstValue, secondValue, thirdValue)(str);
	}

	return str;
};

export default colorize;



================================================
FILE: src/devtools-window-polyfill.ts
================================================
// Ignoring missing types error to avoid adding another dependency for this hack to work
import ws from 'ws';

// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
const customGlobal = global as any;

// These things must exist before importing `react-devtools-core`

// eslint-disable-next-line n/no-unsupported-features/node-builtins
customGlobal.WebSocket ||= ws;

customGlobal.window ||= global;

customGlobal.self ||= global;

// Filter out Ink's internal components from devtools for a cleaner view.
// Also, ince `react-devtools-shared` package isn't published on npm, we can't
// use its types, that's why there are hard-coded values in `type` fields below.
// See https://github.com/facebook/react/blob/edf6eac8a181860fd8a2d076a43806f1237495a1/packages/react-devtools-shared/src/types.js#L24
customGlobal.window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = [
	{
		// ComponentFilterElementType
		type: 1,
		// ElementTypeHostComponent
		value: 7,
		isEnabled: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalApp',
		isEnabled: true,
		isValid: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalAppContext',
		isEnabled: true,
		isValid: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalStdoutContext',
		isEnabled: true,
		isValid: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalStderrContext',
		isEnabled: true,
		isValid: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalStdinContext',
		isEnabled: true,
		isValid: true,
	},
	{
		// ComponentFilterDisplayName
		type: 2,
		value: 'InternalFocusContext',
		isEnabled: true,
		isValid: true,
	},
];



================================================
FILE: src/devtools.ts
================================================
/* eslint-disable import/order */

// eslint-disable-next-line import/no-unassigned-import
import './devtools-window-polyfill.js';

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-expect-error
import devtools from 'react-devtools-core';

// eslint-disable-next-line @typescript-eslint/no-unsafe-call
(devtools as any).initialize();
// eslint-disable-next-line @typescript-eslint/no-unsafe-call
(devtools as any).connectToDevTools();



================================================
FILE: src/dom.ts
================================================
import Yoga, {type Node as YogaNode} from 'yoga-layout';
import measureText from './measure-text.js';
import {type Styles} from './styles.js';
import wrapText from './wrap-text.js';
import squashTextNodes from './squash-text-nodes.js';
import {type OutputTransformer} from './render-node-to-output.js';

type InkNode = {
	parentNode: DOMElement | undefined;
	yogaNode?: YogaNode;
	internal_static?: boolean;
	style: Styles;
};

export type TextName = '#text';
export type ElementNames =
	| 'ink-root'
	| 'ink-box'
	| 'ink-text'
	| 'ink-virtual-text';

export type NodeNames = ElementNames | TextName;

// eslint-disable-next-line @typescript-eslint/naming-convention
export type DOMElement = {
	nodeName: ElementNames;
	attributes: Record<string, DOMNodeAttribute>;
	childNodes: DOMNode[];
	internal_transform?: OutputTransformer;

	internal_accessibility?: {
		role?:
			| 'button'
			| 'checkbox'
			| 'combobox'
			| 'list'
			| 'listbox'
			| 'listitem'
			| 'menu'
			| 'menuitem'
			| 'option'
			| 'progressbar'
			| 'radio'
			| 'radiogroup'
			| 'tab'
			| 'tablist'
			| 'table'
			| 'textbox'
			| 'timer'
			| 'toolbar';
		state?: {
			busy?: boolean;
			checked?: boolean;
			disabled?: boolean;
			expanded?: boolean;
			multiline?: boolean;
			multiselectable?: boolean;
			readonly?: boolean;
			required?: boolean;
			selected?: boolean;
		};
	};

	// Internal properties
	isStaticDirty?: boolean;
	staticNode?: DOMElement;
	onComputeLayout?: () => void;
	onRender?: () => void;
	onImmediateRender?: () => void;
} & InkNode;

export type TextNode = {
	nodeName: TextName;
	nodeValue: string;
} & InkNode;

// eslint-disable-next-line @typescript-eslint/naming-convention
export type DOMNode<T = {nodeName: NodeNames}> = T extends {
	nodeName: infer U;
}
	? U extends '#text'
		? TextNode
		: DOMElement
	: never;

// eslint-disable-next-line @typescript-eslint/naming-convention
export type DOMNodeAttribute = boolean | string | number;

export const createNode = (nodeName: ElementNames): DOMElement => {
	const node: DOMElement = {
		nodeName,
		style: {},
		attributes: {},
		childNodes: [],
		parentNode: undefined,
		yogaNode: nodeName === 'ink-virtual-text' ? undefined : Yoga.Node.create(),
		// eslint-disable-next-line @typescript-eslint/naming-convention
		internal_accessibility: {},
	};

	if (nodeName === 'ink-text') {
		node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node));
	}

	return node;
};

export const appendChildNode = (
	node: DOMElement,
	childNode: DOMElement,
): void => {
	if (childNode.parentNode) {
		removeChildNode(childNode.parentNode, childNode);
	}

	childNode.parentNode = node;
	node.childNodes.push(childNode);

	if (childNode.yogaNode) {
		node.yogaNode?.insertChild(
			childNode.yogaNode,
			node.yogaNode.getChildCount(),
		);
	}

	if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
		markNodeAsDirty(node);
	}
};

export const insertBeforeNode = (
	node: DOMElement,
	newChildNode: DOMNode,
	beforeChildNode: DOMNode,
): void => {
	if (newChildNode.parentNode) {
		removeChildNode(newChildNode.parentNode, newChildNode);
	}

	newChildNode.parentNode = node;

	const index = node.childNodes.indexOf(beforeChildNode);
	if (index >= 0) {
		node.childNodes.splice(index, 0, newChildNode);
		if (newChildNode.yogaNode) {
			node.yogaNode?.insertChild(newChildNode.yogaNode, index);
		}

		return;
	}

	node.childNodes.push(newChildNode);

	if (newChildNode.yogaNode) {
		node.yogaNode?.insertChild(
			newChildNode.yogaNode,
			node.yogaNode.getChildCount(),
		);
	}

	if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
		markNodeAsDirty(node);
	}
};

export const removeChildNode = (
	node: DOMElement,
	removeNode: DOMNode,
): void => {
	if (removeNode.yogaNode) {
		removeNode.parentNode?.yogaNode?.removeChild(removeNode.yogaNode);
	}

	removeNode.parentNode = undefined;

	const index = node.childNodes.indexOf(removeNode);
	if (index >= 0) {
		node.childNodes.splice(index, 1);
	}

	if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
		markNodeAsDirty(node);
	}
};

export const setAttribute = (
	node: DOMElement,
	key: string,
	value: DOMNodeAttribute,
): void => {
	if (key === 'internal_accessibility') {
		node.internal_accessibility = value as DOMElement['internal_accessibility'];
		return;
	}

	node.attributes[key] = value;
};

export const setStyle = (node: DOMNode, style: Styles): void => {
	node.style = style;
};

export const createTextNode = (text: string): TextNode => {
	const node: TextNode = {
		nodeName: '#text',
		nodeValue: text,
		yogaNode: undefined,
		parentNode: undefined,
		style: {},
	};

	setTextNodeValue(node, text);

	return node;
};

const measureTextNode = function (
	node: DOMNode,
	width: number,
): {width: number; height: number} {
	const text =
		node.nodeName === '#text' ? node.nodeValue : squashTextNodes(node);

	const dimensions = measureText(text);

	// Text fits into container, no need to wrap
	if (dimensions.width <= width) {
		return dimensions;
	}

	// This is happening when <Box> is shrinking child nodes and Yoga asks
	// if we can fit this text node in a <1px space, so we just tell Yoga "no"
	if (dimensions.width >= 1 && width > 0 && width < 1) {
		return dimensions;
	}

	const textWrap = node.style?.textWrap ?? 'wrap';
	const wrappedText = wrapText(text, width, textWrap);

	return measureText(wrappedText);
};

const findClosestYogaNode = (node?: DOMNode): YogaNode | undefined => {
	if (!node?.parentNode) {
		return undefined;
	}

	return node.yogaNode ?? findClosestYogaNode(node.parentNode);
};

const markNodeAsDirty = (node?: DOMNode): void => {
	// Mark closest Yoga node as dirty to measure text dimensions again
	const yogaNode = findClosestYogaNode(node);
	yogaNode?.markDirty();
};

export const setTextNodeValue = (node: TextNode, text: string): void => {
	if (typeof text !== 'string') {
		text = String(text);
	}

	node.nodeValue = text;
	markNodeAsDirty(node);
};



================================================
FILE: src/get-max-width.ts
================================================
import Yoga, {type Node as YogaNode} from 'yoga-layout';

const getMaxWidth = (yogaNode: YogaNode) => {
	return (
		yogaNode.getComputedWidth() -
		yogaNode.getComputedPadding(Yoga.EDGE_LEFT) -
		yogaNode.getComputedPadding(Yoga.EDGE_RIGHT) -
		yogaNode.getComputedBorder(Yoga.EDGE_LEFT) -
		yogaNode.getComputedBorder(Yoga.EDGE_RIGHT)
	);
};

export default getMaxWidth;



================================================
FILE: src/global.d.ts
================================================
import {type ReactNode, type Key, type LegacyRef} from 'react';
import {type Except} from 'type-fest';
import {type DOMElement} from './dom.js';
import {type Styles} from './styles.js';

declare module 'react' {
	namespace JSX {
		// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
		interface IntrinsicElements {
			'ink-box': Ink.Box;
			'ink-text': Ink.Text;
		}
	}
}

declare namespace Ink {
	type Box = {
		internal_static?: boolean;
		children?: ReactNode;
		key?: Key;
		ref?: LegacyRef<DOMElement>;
		style?: Except<Styles, 'textWrap'>;
		internal_accessibility?: DOMElement['internal_accessibility'];
	};

	type Text = {
		children?: ReactNode;
		key?: Key;
		style?: Styles;

		// eslint-disable-next-line @typescript-eslint/naming-convention
		internal_transform?: (children: string, index: number) => string;
		internal_accessibility?: DOMElement['internal_accessibility'];
	};
}



================================================
FILE: src/index.ts
================================================
export type {RenderOptions, Instance} from './render.js';
export {default as render} from './render.js';
export type {Props as BoxProps} from './components/Box.js';
export {default as Box} from './components/Box.js';
export type {Props as TextProps} from './components/Text.js';
export {default as Text} from './components/Text.js';
export type {Props as AppProps} from './components/AppContext.js';
export type {Props as StdinProps} from './components/StdinContext.js';
export type {Props as StdoutProps} from './components/StdoutContext.js';
export type {Props as StderrProps} from './components/StderrContext.js';
export type {Props as StaticProps} from './components/Static.js';
export {default as Static} from './components/Static.js';
export type {Props as TransformProps} from './components/Transform.js';
export {default as Transform} from './components/Transform.js';
export type {Props as NewlineProps} from './components/Newline.js';
export {default as Newline} from './components/Newline.js';
export {default as Spacer} from './components/Spacer.js';
export type {Key} from './hooks/use-input.js';
export {default as useInput} from './hooks/use-input.js';
export {default as useApp} from './hooks/use-app.js';
export {default as useStdin} from './hooks/use-stdin.js';
export {default as useStdout} from './hooks/use-stdout.js';
export {default as useStderr} from './hooks/use-stderr.js';
export {default as useFocus} from './hooks/use-focus.js';
export {default as useFocusManager} from './hooks/use-focus-manager.js';
export {default as useIsScreenReaderEnabled} from './hooks/use-is-screen-reader-enabled.js';
export {default as measureElement} from './measure-element.js';
export type {DOMElement} from './dom.js';



================================================
FILE: src/ink.tsx
================================================
import process from 'node:process';
import React, {type ReactNode} from 'react';
import {throttle} from 'es-toolkit/compat';
import ansiEscapes from 'ansi-escapes';
import isInCi from 'is-in-ci';
import autoBind from 'auto-bind';
import signalExit from 'signal-exit';
import patchConsole from 'patch-console';
import {LegacyRoot} from 'react-reconciler/constants.js';
import {type FiberRoot} from 'react-reconciler';
import Yoga from 'yoga-layout';
import wrapAnsi from 'wrap-ansi';
import reconciler from './reconciler.js';
import render from './renderer.js';
import * as dom from './dom.js';
import logUpdate, {type LogUpdate} from './log-update.js';
import instances from './instances.js';
import App from './components/App.js';
import {accessibilityContext as AccessibilityContext} from './components/AccessibilityContext.js';

const noop = () => {};

/**
Performance metrics for a render operation.
*/
export type RenderMetrics = {
	/**
	Time spent rendering in milliseconds.
	*/
	renderTime: number;
};

export type Options = {
	stdout: NodeJS.WriteStream;
	stdin: NodeJS.ReadStream;
	stderr: NodeJS.WriteStream;
	debug: boolean;
	exitOnCtrlC: boolean;
	patchConsole: boolean;
	onRender?: (metrics: RenderMetrics) => void;
	isScreenReaderEnabled?: boolean;
	waitUntilExit?: () => Promise<void>;
	maxFps?: number;
};

export default class Ink {
	private readonly options: Options;
	private readonly log: LogUpdate;
	private readonly throttledLog: LogUpdate;
	private readonly isScreenReaderEnabled: boolean;

	// Ignore last render after unmounting a tree to prevent empty output before exit
	private isUnmounted: boolean;
	private lastOutput: string;
	private lastOutputHeight: number;
	private readonly container: FiberRoot;
	private readonly rootNode: dom.DOMElement;
	// This variable is used only in debug mode to store full static output
	// so that it's rerendered every time, not just new static parts, like in non-debug mode
	private fullStaticOutput: string;
	private exitPromise?: Promise<void>;
	private restoreConsole?: () => void;
	private readonly unsubscribeResize?: () => void;

	constructor(options: Options) {
		autoBind(this);

		this.options = options;
		this.rootNode = dom.createNode('ink-root');
		this.rootNode.onComputeLayout = this.calculateLayout;

		this.isScreenReaderEnabled =
			options.isScreenReaderEnabled ??
			process.env['INK_SCREEN_READER'] === 'true';

		const unthrottled = options.debug || this.isScreenReaderEnabled;
		const maxFps = options.maxFps ?? 30;
		const renderThrottleMs =
			maxFps > 0 ? Math.max(1, Math.ceil(1000 / maxFps)) : 0;

		this.rootNode.onRender = unthrottled
			? this.onRender
			: throttle(this.onRender, renderThrottleMs, {
					leading: true,
					trailing: true,
				});

		this.rootNode.onImmediateRender = this.onRender;
		this.log = logUpdate.create(options.stdout);
		this.throttledLog = unthrottled
			? this.log
			: (throttle(this.log, undefined, {
					leading: true,
					trailing: true,
				}) as unknown as LogUpdate);

		// Ignore last render after unmounting a tree to prevent empty output before exit
		this.isUnmounted = false;

		// Store last output to only rerender when needed
		this.lastOutput = '';
		this.lastOutputHeight = 0;

		// This variable is used only in debug mode to store full static output
		// so that it's rerendered every time, not just new static parts, like in non-debug mode
		this.fullStaticOutput = '';

		// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
		this.container = reconciler.createContainer(
			this.rootNode,
			LegacyRoot,
			null,
			false,
			null,
			'id',
			() => {},
			() => {},
			() => {},
			() => {},
			null,
		);

		// Unmount when process exits
		this.unsubscribeExit = signalExit(this.unmount, {alwaysLast: false});

		if (process.env['DEV'] === 'true') {
			reconciler.injectIntoDevTools({
				bundleType: 0,
				// Reporting React DOM's version, not Ink's
				// See https://github.com/facebook/react/issues/16666#issuecomment-532639905
				version: '16.13.1',
				rendererPackageName: 'ink',
			});
		}

		if (options.patchConsole) {
			this.patchConsole();
		}

		if (!isInCi) {
			options.stdout.on('resize', this.resized);

			this.unsubscribeResize = () => {
				options.stdout.off('resize', this.resized);
			};
		}
	}

	resized = () => {
		this.calculateLayout();
		this.onRender();
	};

	resolveExitPromise: () => void = () => {};
	rejectExitPromise: (reason?: Error) => void = () => {};
	unsubscribeExit: () => void = () => {};

	calculateLayout = () => {
		// The 'columns' property can be undefined or 0 when not using a TTY.
		// In that case we fall back to 80.
		const terminalWidth = this.options.stdout.columns || 80;

		this.rootNode.yogaNode!.setWidth(terminalWidth);

		this.rootNode.yogaNode!.calculateLayout(
			undefined,
			undefined,
			Yoga.DIRECTION_LTR,
		);
	};

	onRender: () => void = () => {
		if (this.isUnmounted) {
			return;
		}

		const startTime = performance.now();
		const {output, outputHeight, staticOutput} = render(
			this.rootNode,
			this.isScreenReaderEnabled,
		);

		this.options.onRender?.({renderTime: performance.now() - startTime});

		// If <Static> output isn't empty, it means new children have been added to it
		const hasStaticOutput = staticOutput && staticOutput !== '\n';

		if (this.options.debug) {
			if (hasStaticOutput) {
				this.fullStaticOutput += staticOutput;
			}

			this.options.stdout.write(this.fullStaticOutput + output);
			return;
		}

		if (isInCi) {
			if (hasStaticOutput) {
				this.options.stdout.write(staticOutput);
			}

			this.lastOutput = output;
			this.lastOutputHeight = outputHeight;
			return;
		}

		if (this.isScreenReaderEnabled) {
			if (hasStaticOutput) {
				// We need to erase the main output before writing new static output
				const erase =
					this.lastOutputHeight > 0
						? ansiEscapes.eraseLines(this.lastOutputHeight)
						: '';
				this.options.stdout.write(erase + staticOutput);
				// After erasing, the last output is gone, so we should reset its height
				this.lastOutputHeight = 0;
			}

			if (output === this.lastOutput && !hasStaticOutput) {
				return;
			}

			const terminalWidth = this.options.stdout.columns || 80;

			const wrappedOutput = wrapAnsi(output, terminalWidth, {
				trim: false,
				hard: true,
			});

			// If we haven't erased yet, do it now.
			if (hasStaticOutput) {
				this.options.stdout.write(wrappedOutput);
			} else {
				const erase =
					this.lastOutputHeight > 0
						? ansiEscapes.eraseLines(this.lastOutputHeight)
						: '';
				this.options.stdout.write(erase + wrappedOutput);
			}

			this.lastOutput = output;
			this.lastOutputHeight =
				wrappedOutput === '' ? 0 : wrappedOutput.split('\n').length;
			return;
		}

		if (hasStaticOutput) {
			this.fullStaticOutput += staticOutput;
		}

		if (this.lastOutputHeight >= this.options.stdout.rows) {
			this.options.stdout.write(
				ansiEscapes.clearTerminal + this.fullStaticOutput + output,
			);
			this.lastOutput = output;
			this.lastOutputHeight = outputHeight;
			this.log.sync(output);
			return;
		}

		// To ensure static output is cleanly rendered before main output, clear main output first
		if (hasStaticOutput) {
			this.log.clear();
			this.options.stdout.write(staticOutput);
			this.log(output);
		}

		if (!hasStaticOutput && output !== this.lastOutput) {
			this.throttledLog(output);
		}

		this.lastOutput = output;
		this.lastOutputHeight = outputHeight;
	};

	render(node: ReactNode): void {
		const tree = (
			<AccessibilityContext.Provider
				value={{isScreenReaderEnabled: this.isScreenReaderEnabled}}
			>
				<App
					stdin={this.options.stdin}
					stdout={this.options.stdout}
					stderr={this.options.stderr}
					writeToStdout={this.writeToStdout}
					writeToStderr={this.writeToStderr}
					exitOnCtrlC={this.options.exitOnCtrlC}
					onExit={this.unmount}
				>
					{node}
				</App>
			</AccessibilityContext.Provider>
		);

		// @ts-expect-error the types for `react-reconciler` are not up to date with the library.
		// eslint-disable-next-line @typescript-eslint/no-unsafe-call
		reconciler.updateContainerSync(tree, this.container, null, noop);
		// @ts-expect-error the types for `react-reconciler` are not up to date with the library.
		// eslint-disable-next-line @typescript-eslint/no-unsafe-call
		reconciler.flushSyncWork();
	}

	writeToStdout(data: string): void {
		if (this.isUnmounted) {
			return;
		}

		if (this.options.debug) {
			this.options.stdout.write(data + this.fullStaticOutput + this.lastOutput);
			return;
		}

		if (isInCi) {
			this.options.stdout.write(data);
			return;
		}

		this.log.clear();
		this.options.stdout.write(data);
		this.log(this.lastOutput);
	}

	writeToStderr(data: string): void {
		if (this.isUnmounted) {
			return;
		}

		if (this.options.debug) {
			this.options.stderr.write(data);
			this.options.stdout.write(this.fullStaticOutput + this.lastOutput);
			return;
		}

		if (isInCi) {
			this.options.stderr.write(data);
			return;
		}

		this.log.clear();
		this.options.stderr.write(data);
		this.log(this.lastOutput);
	}

	// eslint-disable-next-line @typescript-eslint/ban-types
	unmount(error?: Error | number | null): void {
		if (this.isUnmounted) {
			return;
		}

		this.calculateLayout();
		this.onRender();
		this.unsubscribeExit();

		if (typeof this.restoreConsole === 'function') {
			this.restoreConsole();
		}

		if (typeof this.unsubscribeResize === 'function') {
			this.unsubscribeResize();
		}

		// CIs don't handle erasing ansi escapes well, so it's better to
		// only render last frame of non-static output
		if (isInCi) {
			this.options.stdout.write(this.lastOutput + '\n');
		} else if (!this.options.debug) {
			this.log.done();
		}

		this.isUnmounted = true;

		// @ts-expect-error the types for `react-reconciler` are not up to date with the library.
		// eslint-disable-next-line @typescript-eslint/no-unsafe-call
		reconciler.updateContainerSync(null, this.container, null, noop);
		// @ts-expect-error the types for `react-reconciler` are not up to date with the library.
		// eslint-disable-next-line @typescript-eslint/no-unsafe-call
		reconciler.flushSyncWork();
		instances.delete(this.options.stdout);

		if (error instanceof Error) {
			this.rejectExitPromise(error);
		} else {
			this.resolveExitPromise();
		}
	}

	async waitUntilExit(): Promise<void> {
		this.exitPromise ||= new Promise((resolve, reject) => {
			this.resolveExitPromise = resolve;
			this.rejectExitPromise = reject;
		});

		return this.exitPromise;
	}

	clear(): void {
		if (!isInCi && !this.options.debug) {
			this.log.clear();
		}
	}

	patchConsole(): void {
		if (this.options.debug) {
			return;
		}

		this.restoreConsole = patchConsole((stream, data) => {
			if (stream === 'stdout') {
				this.writeToStdout(data);
			}

			if (stream === 'stderr') {
				const isReactMessage = data.startsWith('The above error occurred');

				if (!isReactMessage) {
					this.writeToStderr(data);
				}
			}
		});
	}
}



================================================
FILE: src/instances.ts
================================================
// Store all instances of Ink (instance.js) to ensure that consecutive render() calls
// use the same instance of Ink and don't create a new one
//
// This map has to be stored in a separate file, because render.js creates instances,
// but instance.js should delete itself from the map on unmount

import type Ink from './ink.js';

const instances = new WeakMap<NodeJS.WriteStream, Ink>();
export default instances;



================================================
FILE: src/log-update.ts
================================================
import {type Writable} from 'node:stream';
import ansiEscapes from 'ansi-escapes';
import cliCursor from 'cli-cursor';

export type LogUpdate = {
	clear: () => void;
	done: () => void;
	sync: (str: string) => void;
	(str: string): void;
};

const create = (stream: Writable, {showCursor = false} = {}): LogUpdate => {
	let previousLineCount = 0;
	let previousOutput = '';
	let hasHiddenCursor = false;

	const render = (str: string) => {
		if (!showCursor && !hasHiddenCursor) {
			cliCursor.hide();
			hasHiddenCursor = true;
		}

		const output = str + '\n';
		if (output === previousOutput) {
			return;
		}

		previousOutput = output;
		stream.write(ansiEscapes.eraseLines(previousLineCount) + output);
		previousLineCount = output.split('\n').length;
	};

	render.clear = () => {
		stream.write(ansiEscapes.eraseLines(previousLineCount));
		previousOutput = '';
		previousLineCount = 0;
	};

	render.done = () => {
		previousOutput = '';
		previousLineCount = 0;

		if (!showCursor) {
			cliCursor.show();
			hasHiddenCursor = false;
		}
	};

	render.sync = (str: string) => {
		const output = str + '\n';
		previousOutput = output;
		previousLineCount = output.split('\n').length;
	};

	return render;
};

const logUpdate = {create};
export default logUpdate;



================================================
FILE: src/measure-element.ts
================================================
import {type DOMElement} from './dom.js';

type Output = {
	/**
	Element width.
	*/
	width: number;

	/**
	Element height.
	*/
	height: number;
};

/**
Measure the dimensions of a particular `<Box>` element.
*/
const measureElement = (node: DOMElement): Output => ({
	width: node.yogaNode?.getComputedWidth() ?? 0,
	height: node.yogaNode?.getComputedHeight() ?? 0,
});

export default measureElement;



================================================
FILE: src/measure-text.ts
================================================
import widestLine from 'widest-line';

const cache = new Map<string, Output>();

type Output = {
	width: number;
	height: number;
};

const measureText = (text: string): Output => {
	if (text.length === 0) {
		return {
			width: 0,
			height: 0,
		};
	}

	const cachedDimensions = cache.get(text);

	if (cachedDimensions) {
		return cachedDimensions;
	}

	const width = widestLine(text);
	const height = text.split('\n').length;
	const dimensions = {width, height};
	cache.set(text, dimensions);

	return dimensions;
};

export default measureText;



================================================
FILE: src/output.ts
================================================
import sliceAnsi from 'slice-ansi';
import stringWidth from 'string-width';
import widestLine from 'widest-line';
import {
	type StyledChar,
	styledCharsFromTokens,
	styledCharsToString,
	tokenize,
} from '@alcalzone/ansi-tokenize';
import {type OutputTransformer} from './render-node-to-output.js';

/**
"Virtual" output class

Handles the positioning and saving of the output of each node in the tree. Also responsible for applying transformations to each character of the output.

Used to generate the final output of all nodes before writing it to actual output stream (e.g. stdout)
*/

type Options = {
	width: number;
	height: number;
};

type Operation = WriteOperation | ClipOperation | UnclipOperation;

type WriteOperation = {
	type: 'write';
	x: number;
	y: number;
	text: string;
	transformers: OutputTransformer[];
};

type ClipOperation = {
	type: 'clip';
	clip: Clip;
};

type Clip = {
	x1: number | undefined;
	x2: number | undefined;
	y1: number | undefined;
	y2: number | undefined;
};

type UnclipOperation = {
	type: 'unclip';
};

export default class Output {
	width: number;
	height: number;

	private readonly operations: Operation[] = [];

	constructor(options: Options) {
		const {width, height} = options;

		this.width = width;
		this.height = height;
	}

	write(
		x: number,
		y: number,
		text: string,
		options: {transformers: OutputTransformer[]},
	): void {
		const {transformers} = options;

		if (!text) {
			return;
		}

		this.operations.push({
			type: 'write',
			x,
			y,
			text,
			transformers,
		});
	}

	clip(clip: Clip) {
		this.operations.push({
			type: 'clip',
			clip,
		});
	}

	unclip() {
		this.operations.push({
			type: 'unclip',
		});
	}

	get(): {output: string; height: number} {
		// Initialize output array with a specific set of rows, so that margin/padding at the bottom is preserved
		const output: StyledChar[][] = [];

		for (let y = 0; y < this.height; y++) {
			const row: StyledChar[] = [];

			for (let x = 0; x < this.width; x++) {
				row.push({
					type: 'char',
					value: ' ',
					fullWidth: false,
					styles: [],
				});
			}

			output.push(row);
		}

		const clips: Clip[] = [];

		for (const operation of this.operations) {
			if (operation.type === 'clip') {
				clips.push(operation.clip);
			}

			if (operation.type === 'unclip') {
				clips.pop();
			}

			if (operation.type === 'write') {
				const {text, transformers} = operation;
				let {x, y} = operation;
				let lines = text.split('\n');

				const clip = clips.at(-1);

				if (clip) {
					const clipHorizontally =
						typeof clip?.x1 === 'number' && typeof clip?.x2 === 'number';

					const clipVertically =
						typeof clip?.y1 === 'number' && typeof clip?.y2 === 'number';

					// If text is positioned outside of clipping area altogether,
					// skip to the next operation to avoid unnecessary calculations
					if (clipHorizontally) {
						const width = widestLine(text);

						if (x + width < clip.x1! || x > clip.x2!) {
							continue;
						}
					}

					if (clipVertically) {
						const height = lines.length;

						if (y + height < clip.y1! || y > clip.y2!) {
							continue;
						}
					}

					if (clipHorizontally) {
						lines = lines.map(line => {
							const from = x < clip.x1! ? clip.x1! - x : 0;
							const width = stringWidth(line);
							const to = x + width > clip.x2! ? clip.x2! - x : width;

							return sliceAnsi(line, from, to);
						});

						if (x < clip.x1!) {
							x = clip.x1!;
						}
					}

					if (clipVertically) {
						const from = y < clip.y1! ? clip.y1! - y : 0;
						const height = lines.length;
						const to = y + height > clip.y2! ? clip.y2! - y : height;

						lines = lines.slice(from, to);

						if (y < clip.y1!) {
							y = clip.y1!;
						}
					}
				}

				let offsetY = 0;

				for (let [index, line] of lines.entries()) {
					const currentLine = output[y + offsetY];

					// Line can be missing if `text` is taller than height of pre-initialized `this.output`
					if (!currentLine) {
						continue;
					}

					for (const transformer of transformers) {
						line = transformer(line, index);
					}

					const characters = styledCharsFromTokens(tokenize(line));
					let offsetX = x;

					for (const character of characters) {
						currentLine[offsetX] = character;

						// Determine printed width using string-width to align with measurement
						const characterWidth = Math.max(1, stringWidth(character.value));

						// For multi-column characters, clear following cells to avoid stray spaces/artifacts
						if (characterWidth > 1) {
							for (let index = 1; index < characterWidth; index++) {
								currentLine[offsetX + index] = {
									type: 'char',
									value: '',
									fullWidth: false,
									styles: character.styles,
								};
							}
						}

						offsetX += characterWidth;
					}

					offsetY++;
				}
			}
		}

		const generatedOutput = output
			.map(line => {
				// See https://github.com/vadimdemedes/ink/pull/564#issuecomment-1637022742
				const lineWithoutEmptyItems = line.filter(item => item !== undefined);

				return styledCharsToString(lineWithoutEmptyItems).trimEnd();
			})
			.join('\n');

		return {
			output: generatedOutput,
			height: output.length,
		};
	}
}



================================================
FILE: src/parse-keypress.ts
================================================
// Copied from https://github.com/enquirer/enquirer/blob/36785f3399a41cd61e9d28d1eb9c2fcd73d69b4c/lib/keypress.js
import {Buffer} from 'node:buffer';

const metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;

const fnKeyRe =
	/^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;

const keyName: Record<string, string> = {
	/* xterm/gnome ESC O letter */
	OP: 'f1',
	OQ: 'f2',
	OR: 'f3',
	OS: 'f4',
	/* xterm/rxvt ESC [ number ~ */
	'[11~': 'f1',
	'[12~': 'f2',
	'[13~': 'f3',
	'[14~': 'f4',
	/* from Cygwin and used in libuv */
	'[[A': 'f1',
	'[[B': 'f2',
	'[[C': 'f3',
	'[[D': 'f4',
	'[[E': 'f5',
	/* common */
	'[15~': 'f5',
	'[17~': 'f6',
	'[18~': 'f7',
	'[19~': 'f8',
	'[20~': 'f9',
	'[21~': 'f10',
	'[23~': 'f11',
	'[24~': 'f12',
	/* xterm ESC [ letter */
	'[A': 'up',
	'[B': 'down',
	'[C': 'right',
	'[D': 'left',
	'[E': 'clear',
	'[F': 'end',
	'[H': 'home',
	/* xterm/gnome ESC O letter */
	OA: 'up',
	OB: 'down',
	OC: 'right',
	OD: 'left',
	OE: 'clear',
	OF: 'end',
	OH: 'home',
	/* xterm/rxvt ESC [ number ~ */
	'[1~': 'home',
	'[2~': 'insert',
	'[3~': 'delete',
	'[4~': 'end',
	'[5~': 'pageup',
	'[6~': 'pagedown',
	/* putty */
	'[[5~': 'pageup',
	'[[6~': 'pagedown',
	/* rxvt */
	'[7~': 'home',
	'[8~': 'end',
	/* rxvt keys with modifiers */
	'[a': 'up',
	'[b': 'down',
	'[c': 'right',
	'[d': 'left',
	'[e': 'clear',

	'[2$': 'insert',
	'[3$': 'delete',
	'[5$': 'pageup',
	'[6$': 'pagedown',
	'[7$': 'home',
	'[8$': 'end',

	Oa: 'up',
	Ob: 'down',
	Oc: 'right',
	Od: 'left',
	Oe: 'clear',

	'[2^': 'insert',
	'[3^': 'delete',
	'[5^': 'pageup',
	'[6^': 'pagedown',
	'[7^': 'home',
	'[8^': 'end',
	/* misc. */
	'[Z': 'tab',
};

export const nonAlphanumericKeys = [...Object.values(keyName), 'backspace'];

const isShiftKey = (code: string) => {
	return [
		'[a',
		'[b',
		'[c',
		'[d',
		'[e',
		'[2$',
		'[3$',
		'[5$',
		'[6$',
		'[7$',
		'[8$',
		'[Z',
	].includes(code);
};

const isCtrlKey = (code: string) => {
	return [
		'Oa',
		'Ob',
		'Oc',
		'Od',
		'Oe',
		'[2^',
		'[3^',
		'[5^',
		'[6^',
		'[7^',
		'[8^',
	].includes(code);
};

type ParsedKey = {
	name: string;
	ctrl: boolean;
	meta: boolean;
	shift: boolean;
	option: boolean;
	sequence: string;
	raw: string | undefined;
	code?: string;
};

const parseKeypress = (s: Buffer | string = ''): ParsedKey => {
	let parts;

	if (Buffer.isBuffer(s)) {
		if (s[0]! > 127 && s[1] === undefined) {
			(s[0] as unknown as number) -= 128;
			s = '\x1b' + String(s);
		} else {
			s = String(s);
		}
	} else if (s !== undefined && typeof s !== 'string') {
		s = String(s);
	} else if (!s) {
		s = '';
	}

	const key: ParsedKey = {
		name: '',
		ctrl: false,
		meta: false,
		shift: false,
		option: false,
		sequence: s,
		raw: s,
	};

	key.sequence = key.sequence || s || key.name;

	if (s === '\r') {
		// carriage return
		key.raw = undefined;
		key.name = 'return';
	} else if (s === '\n') {
		// enter, should have been called linefeed
		key.name = 'enter';
	} else if (s === '\t') {
		// tab
		key.name = 'tab';
	} else if (s === '\b' || s === '\x1b\b') {
		// backspace or ctrl+h
		key.name = 'backspace';
		key.meta = s.charAt(0) === '\x1b';
	} else if (s === '\x7f' || s === '\x1b\x7f') {
		// TODO(vadimdemedes): `enquirer` detects delete key as backspace, but I had to split them up to avoid breaking changes in Ink. Merge them back together in the next major version.
		// delete
		key.name = 'delete';
		key.meta = s.charAt(0) === '\x1b';
	} else if (s === '\x1b' || s === '\x1b\x1b') {
		// escape key
		key.name = 'escape';
		key.meta = s.length === 2;
	} else if (s === ' ' || s === '\x1b ') {
		key.name = 'space';
		key.meta = s.length === 2;
	} else if (s.length === 1 && s <= '\x1a') {
		// ctrl+letter
		key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
		key.ctrl = true;
	} else if (s.length === 1 && s >= '0' && s <= '9') {
		// number
		key.name = 'number';
	} else if (s.length === 1 && s >= 'a' && s <= 'z') {
		// lowercase letter
		key.name = s;
	} else if (s.length === 1 && s >= 'A' && s <= 'Z') {
		// shift+letter
		key.name = s.toLowerCase();
		key.shift = true;
	} else if ((parts = metaKeyCodeRe.exec(s))) {
		// meta+character key
		key.meta = true;
		key.shift = /^[A-Z]$/.test(parts[1]!);
	} else if ((parts = fnKeyRe.exec(s))) {
		const segs = [...s];

		if (segs[0] === '\u001b' && segs[1] === '\u001b') {
			key.option = true;
		}

		// ansi escape sequence
		// reassemble the key code leaving out leading \x1b's,
		// the modifier key bitflag and any meaningless "1;" sequence
		const code = [parts[1], parts[2], parts[4], parts[6]]
			.filter(Boolean)
			.join('');

		const modifier = ((parts[3] || parts[5] || 1) as number) - 1;

		// Parse the key modifier
		key.ctrl = !!(modifier & 4);
		key.meta = !!(modifier & 10);
		key.shift = !!(modifier & 1);
		key.code = code;

		key.name = keyName[code]!;
		key.shift = isShiftKey(code) || key.shift;
		key.ctrl = isCtrlKey(code) || key.ctrl;
	}

	return key;
};

export default parseKeypress;



================================================
FILE: src/reconciler.ts
================================================
import process from 'node:process';
import createReconciler, {type ReactContext} from 'react-reconciler';
import {
	DefaultEventPriority,
	NoEventPriority,
} from 'react-reconciler/constants.js';
import Yoga, {type Node as YogaNode} from 'yoga-layout';
import {createContext} from 'react';
import {
	createTextNode,
	appendChildNode,
	insertBeforeNode,
	removeChildNode,
	setStyle,
	setTextNodeValue,
	createNode,
	setAttribute,
	type DOMNodeAttribute,
	type TextNode,
	type ElementNames,
	type DOMElement,
} from './dom.js';
import applyStyles, {type Styles} from './styles.js';
import {type OutputTransformer} from './render-node-to-output.js';

// We need to conditionally perform devtools connection to avoid
// accidentally breaking other third-party code.
// See https://github.com/vadimdemedes/ink/issues/384
if (process.env['DEV'] === 'true') {
	try {
		await import('./devtools.js');
	} catch (error: any) {
		if (error.code === 'ERR_MODULE_NOT_FOUND') {
			console.warn(
				`
The environment variable DEV is set to true, so Ink tried to import \`react-devtools-core\`,
but this failed as it was not installed. Debugging with React Devtools requires it.

To install use this command:

$ npm install --save-dev react-devtools-core
				`.trim() + '\n',
			);
		} else {
			// eslint-disable-next-line @typescript-eslint/only-throw-error
			throw error;
		}
	}
}

type AnyObject = Record<string, unknown>;

const diff = (before: AnyObject, after: AnyObject): AnyObject | undefined => {
	if (before === after) {
		return;
	}

	if (!before) {
		return after;
	}

	const changed: AnyObject = {};
	let isChanged = false;

	for (const key of Object.keys(before)) {
		const isDeleted = after ? !Object.hasOwn(after, key) : true;

		if (isDeleted) {
			changed[key] = undefined;
			isChanged = true;
		}
	}

	if (after) {
		for (const key of Object.keys(after)) {
			if (after[key] !== before[key]) {
				changed[key] = after[key];
				isChanged = true;
			}
		}
	}

	return isChanged ? changed : undefined;
};

const cleanupYogaNode = (node?: YogaNode): void => {
	node?.unsetMeasureFunc();
	node?.freeRecursive();
};

type Props = Record<string, unknown>;

type HostContext = {
	isInsideText: boolean;
};

let currentUpdatePriority = NoEventPriority;

let currentRootNode: DOMElement | undefined;

export default createReconciler<
	ElementNames,
	Props,
	DOMElement,
	DOMElement,
	TextNode,
	DOMElement,
	unknown,
	unknown,
	unknown,
	HostContext,
	unknown,
	unknown,
	unknown,
	unknown
>({
	getRootHostContext: () => ({
		isInsideText: false,
	}),
	prepareForCommit: () => null,
	preparePortalMount: () => null,
	clearContainer: () => false,
	resetAfterCommit(rootNode) {
		if (typeof rootNode.onComputeLayout === 'function') {
			rootNode.onComputeLayout();
		}

		// Since renders are throttled at the instance level and <Static> component children
		// are rendered only once and then get deleted, we need an escape hatch to
		// trigger an immediate render to ensure <Static> children are written to output before they get erased
		if (rootNode.isStaticDirty) {
			rootNode.isStaticDirty = false;
			if (typeof rootNode.onImmediateRender === 'function') {
				rootNode.onImmediateRender();
			}

			return;
		}

		if (typeof rootNode.onRender === 'function') {
			rootNode.onRender();
		}
	},
	getChildHostContext(parentHostContext, type) {
		const previousIsInsideText = parentHostContext.isInsideText;
		const isInsideText = type === 'ink-text' || type === 'ink-virtual-text';

		if (previousIsInsideText === isInsideText) {
			return parentHostContext;
		}

		return {isInsideText};
	},
	shouldSetTextContent: () => false,
	createInstance(originalType, newProps, rootNode, hostContext) {
		if (hostContext.isInsideText && originalType === 'ink-box') {
			throw new Error(`<Box> can’t be nested inside <Text> component`);
		}

		const type =
			originalType === 'ink-text' && hostContext.isInsideText
				? 'ink-virtual-text'
				: originalType;

		const node = createNode(type);

		for (const [key, value] of Object.entries(newProps)) {
			if (key === 'children') {
				continue;
			}

			if (key === 'style') {
				setStyle(node, value as Styles);

				if (node.yogaNode) {
					applyStyles(node.yogaNode, value as Styles);
				}

				continue;
			}

			if (key === 'internal_transform') {
				node.internal_transform = value as OutputTransformer;
				continue;
			}

			if (key === 'internal_static') {
				currentRootNode = rootNode;
				node.internal_static = true;
				rootNode.isStaticDirty = true;

				// Save reference to <Static> node to skip traversal of entire
				// node tree to find it
				rootNode.staticNode = node;
				continue;
			}

			setAttribute(node, key, value as DOMNodeAttribute);
		}

		return node;
	},
	createTextInstance(text, _root, hostContext) {
		if (!hostContext.isInsideText) {
			throw new Error(
				`Text string "${text}" must be rendered inside <Text> component`,
			);
		}

		return createTextNode(text);
	},
	resetTextContent() {},
	hideTextInstance(node) {
		setTextNodeValue(node, '');
	},
	unhideTextInstance(node, text) {
		setTextNodeValue(node, text);
	},
	getPublicInstance: instance => instance,
	hideInstance(node) {
		node.yogaNode?.setDisplay(Yoga.DISPLAY_NONE);
	},
	unhideInstance(node) {
		node.yogaNode?.setDisplay(Yoga.DISPLAY_FLEX);
	},
	appendInitialChild: appendChildNode,
	appendChild: appendChildNode,
	insertBefore: insertBeforeNode,
	finalizeInitialChildren() {
		return false;
	},
	isPrimaryRenderer: true,
	supportsMutation: true,
	supportsPersistence: false,
	supportsHydration: false,
	scheduleTimeout: setTimeout,
	cancelTimeout: clearTimeout,
	noTimeout: -1,
	beforeActiveInstanceBlur() {},
	afterActiveInstanceBlur() {},
	detachDeletedInstance() {},
	getInstanceFromNode: () => null,
	prepareScopeUpdate() {},
	getInstanceFromScope: () => null,
	appendChildToContainer: appendChildNode,
	insertInContainerBefore: insertBeforeNode,
	removeChildFromContainer(node, removeNode) {
		removeChildNode(node, removeNode);
		cleanupYogaNode(removeNode.yogaNode);
	},
	commitUpdate(node, _type, oldProps, newProps) {
		if (currentRootNode && node.internal_static) {
			currentRootNode.isStaticDirty = true;
		}

		const props = diff(oldProps, newProps);

		const style = diff(
			oldProps['style'] as Styles,
			newProps['style'] as Styles,
		);

		if (!props && !style) {
			return;
		}

		if (props) {
			for (const [key, value] of Object.entries(props)) {
				if (key === 'style') {
					setStyle(node, value as Styles);
					continue;
				}

				if (key === 'internal_transform') {
					node.internal_transform = value as OutputTransformer;
					continue;
				}

				if (key === 'internal_static') {
					node.internal_static = true;
					continue;
				}

				setAttribute(node, key, value as DOMNodeAttribute);
			}
		}

		if (style && node.yogaNode) {
			applyStyles(node.yogaNode, style);
		}
	},
	commitTextUpdate(node, _oldText, newText) {
		setTextNodeValue(node, newText);
	},
	removeChild(node, removeNode) {
		removeChildNode(node, removeNode);
		cleanupYogaNode(removeNode.yogaNode);
	},
	setCurrentUpdatePriority(newPriority: number) {
		currentUpdatePriority = newPriority;
	},
	getCurrentUpdatePriority: () => currentUpdatePriority,
	resolveUpdatePriority() {
		if (currentUpdatePriority !== NoEventPriority) {
			return currentUpdatePriority;
		}

		return DefaultEventPriority;
	},
	maySuspendCommit() {
		return false;
	},
	// eslint-disable-next-line @typescript-eslint/naming-convention
	NotPendingTransition: undefined,
	// eslint-disable-next-line @typescript-eslint/naming-convention
	HostTransitionContext: createContext(
		null,
	) as unknown as ReactContext<unknown>,
	resetFormInstance() {},
	requestPostPaintCallback() {},
	shouldAttemptEagerTransition() {
		return false;
	},
	trackSchedulerEvent() {},
	resolveEventType() {
		return null;
	},
	resolveEventTimeStamp() {
		return -1.1;
	},
	preloadInstance() {
		return true;
	},
	startSuspendingCommit() {},
	suspendInstance() {},
	waitForCommitToBeReady() {
		return null;
	},
});



================================================
FILE: src/render-background.ts
================================================
import colorize from './colorize.js';
import {type DOMNode} from './dom.js';
import type Output from './output.js';

const renderBackground = (
	x: number,
	y: number,
	node: DOMNode,
	output: Output,
): void => {
	if (!node.style.backgroundColor) {
		return;
	}

	const width = node.yogaNode!.getComputedWidth();
	const height = node.yogaNode!.getComputedHeight();

	// Calculate the actual content area considering borders
	const leftBorderWidth =
		node.style.borderStyle && node.style.borderLeft !== false ? 1 : 0;
	const rightBorderWidth =
		node.style.borderStyle && node.style.borderRight !== false ? 1 : 0;
	const topBorderHeight =
		node.style.borderStyle && node.style.borderTop !== false ? 1 : 0;
	const bottomBorderHeight =
		node.style.borderStyle && node.style.borderBottom !== false ? 1 : 0;

	const contentWidth = width - leftBorderWidth - rightBorderWidth;
	const contentHeight = height - topBorderHeight - bottomBorderHeight;

	if (!(contentWidth > 0 && contentHeight > 0)) {
		return;
	}

	// Create background fill for each row
	const backgroundLine = colorize(
		' '.repeat(contentWidth),
		node.style.backgroundColor,
		'background',
	);

	for (let row = 0; row < contentHeight; row++) {
		output.write(
			x + leftBorderWidth,
			y + topBorderHeight + row,
			backgroundLine,
			{transformers: []},
		);
	}
};

export default renderBackground;



================================================
FILE: src/render-border.ts
================================================
import cliBoxes from 'cli-boxes';
import chalk from 'chalk';
import colorize from './colorize.js';
import {type DOMNode} from './dom.js';
import type Output from './output.js';

const renderBorder = (
	x: number,
	y: number,
	node: DOMNode,
	output: Output,
): void => {
	if (node.style.borderStyle) {
		const width = node.yogaNode!.getComputedWidth();
		const height = node.yogaNode!.getComputedHeight();
		const box =
			typeof node.style.borderStyle === 'string'
				? cliBoxes[node.style.borderStyle]
				: node.style.borderStyle;

		const topBorderColor = node.style.borderTopColor ?? node.style.borderColor;
		const bottomBorderColor =
			node.style.borderBottomColor ?? node.style.borderColor;
		const leftBorderColor =
			node.style.borderLeftColor ?? node.style.borderColor;
		const rightBorderColor =
			node.style.borderRightColor ?? node.style.borderColor;

		const dimTopBorderColor =
			node.style.borderTopDimColor ?? node.style.borderDimColor;

		const dimBottomBorderColor =
			node.style.borderBottomDimColor ?? node.style.borderDimColor;

		const dimLeftBorderColor =
			node.style.borderLeftDimColor ?? node.style.borderDimColor;

		const dimRightBorderColor =
			node.style.borderRightDimColor ?? node.style.borderDimColor;

		const showTopBorder = node.style.borderTop !== false;
		const showBottomBorder = node.style.borderBottom !== false;
		const showLeftBorder = node.style.borderLeft !== false;
		const showRightBorder = node.style.borderRight !== false;

		const contentWidth =
			width - (showLeftBorder ? 1 : 0) - (showRightBorder ? 1 : 0);

		let topBorder = showTopBorder
			? colorize(
					(showLeftBorder ? box.topLeft : '') +
						box.top.repeat(contentWidth) +
						(showRightBorder ? box.topRight : ''),
					topBorderColor,
					'foreground',
				)
			: undefined;

		if (showTopBorder && dimTopBorderColor) {
			topBorder = chalk.dim(topBorder);
		}

		let verticalBorderHeight = height;

		if (showTopBorder) {
			verticalBorderHeight -= 1;
		}

		if (showBottomBorder) {
			verticalBorderHeight -= 1;
		}

		let leftBorder = (
			colorize(box.left, leftBorderColor, 'foreground') + '\n'
		).repeat(verticalBorderHeight);

		if (dimLeftBorderColor) {
			leftBorder = chalk.dim(leftBorder);
		}

		let rightBorder = (
			colorize(box.right, rightBorderColor, 'foreground') + '\n'
		).repeat(verticalBorderHeight);

		if (dimRightBorderColor) {
			rightBorder = chalk.dim(rightBorder);
		}

		let bottomBorder = showBottomBorder
			? colorize(
					(showLeftBorder ? box.bottomLeft : '') +
						box.bottom.repeat(contentWidth) +
						(showRightBorder ? box.bottomRight : ''),
					bottomBorderColor,
					'foreground',
				)
			: undefined;

		if (showBottomBorder && dimBottomBorderColor) {
			bottomBorder = chalk.dim(bottomBorder);
		}

		const offsetY = showTopBorder ? 1 : 0;

		if (topBorder) {
			output.write(x, y, topBorder, {transformers: []});
		}

		if (showLeftBorder) {
			output.write(x, y + offsetY, leftBorder, {transformers: []});
		}

		if (showRightBorder) {
			output.write(x + width - 1, y + offsetY, rightBorder, {
				transformers: [],
			});
		}

		if (bottomBorder) {
			output.write(x, y + height - 1, bottomBorder, {transformers: []});
		}
	}
};

export default renderBorder;



================================================
FILE: src/render-node-to-output.ts
================================================
import widestLine from 'widest-line';
import indentString from 'indent-string';
import Yoga from 'yoga-layout';
import wrapText from './wrap-text.js';
import getMaxWidth from './get-max-width.js';
import squashTextNodes from './squash-text-nodes.js';
import renderBorder from './render-border.js';
import renderBackground from './render-background.js';
import {type DOMElement} from './dom.js';
import type Output from './output.js';

// If parent container is `<Box>`, text nodes will be treated as separate nodes in
// the tree and will have their own coordinates in the layout.
// To ensure text nodes are aligned correctly, take X and Y of the first text node
// and use it as offset for the rest of the nodes
// Only first node is taken into account, because other text nodes can't have margin or padding,
// so their coordinates will be relative to the first node anyway
const applyPaddingToText = (node: DOMElement, text: string): string => {
	const yogaNode = node.childNodes[0]?.yogaNode;

	if (yogaNode) {
		const offsetX = yogaNode.getComputedLeft();
		const offsetY = yogaNode.getComputedTop();
		text = '\n'.repeat(offsetY) + indentString(text, offsetX);
	}

	return text;
};

export type OutputTransformer = (s: string, index: number) => string;

export const renderNodeToScreenReaderOutput = (
	node: DOMElement,
	options: {
		parentRole?: string;
		skipStaticElements?: boolean;
	} = {},
): string => {
	if (options.skipStaticElements && node.internal_static) {
		return '';
	}

	if (node.yogaNode?.getDisplay() === Yoga.DISPLAY_NONE) {
		return '';
	}

	let output = '';

	if (node.nodeName === 'ink-text') {
		output = squashTextNodes(node);
	} else if (node.nodeName === 'ink-box' || node.nodeName === 'ink-root') {
		const separator =
			node.style.flexDirection === 'row' ||
			node.style.flexDirection === 'row-reverse'
				? ' '
				: '\n';

		const childNodes =
			node.style.flexDirection === 'row-reverse' ||
			node.style.flexDirection === 'column-reverse'
				? [...node.childNodes].reverse()
				: [...node.childNodes];

		output = childNodes
			.map(childNode => {
				const screenReaderOutput = renderNodeToScreenReaderOutput(
					childNode as DOMElement,
					{
						parentRole: node.internal_accessibility?.role,
						skipStaticElements: options.skipStaticElements,
					},
				);
				return screenReaderOutput;
			})
			.filter(Boolean)
			.join(separator);
	}

	if (node.internal_accessibility) {
		const {role, state} = node.internal_accessibility;

		if (state) {
			const stateKeys = Object.keys(state) as Array<keyof typeof state>;
			const stateDescription = stateKeys.filter(key => state[key]).join(', ');

			if (stateDescription) {
				output = `(${stateDescription}) ${output}`;
			}
		}

		if (role && role !== options.parentRole) {
			output = `${role}: ${output}`;
		}
	}

	return output;
};

// After nodes are laid out, render each to output object, which later gets rendered to terminal
const renderNodeToOutput = (
	node: DOMElement,
	output: Output,
	options: {
		offsetX?: number;
		offsetY?: number;
		transformers?: OutputTransformer[];
		skipStaticElements: boolean;
	},
) => {
	const {
		offsetX = 0,
		offsetY = 0,
		transformers = [],
		skipStaticElements,
	} = options;

	if (skipStaticElements && node.internal_static) {
		return;
	}

	const {yogaNode} = node;

	if (yogaNode) {
		if (yogaNode.getDisplay() === Yoga.DISPLAY_NONE) {
			return;
		}

		// Left and top positions in Yoga are relative to their parent node
		const x = offsetX + yogaNode.getComputedLeft();
		const y = offsetY + yogaNode.getComputedTop();

		// Transformers are functions that transform final text output of each component
		// See Output class for logic that applies transformers
		let newTransformers = transformers;

		if (typeof node.internal_transform === 'function') {
			newTransformers = [node.internal_transform, ...transformers];
		}

		if (node.nodeName === 'ink-text') {
			let text = squashTextNodes(node);

			if (text.length > 0) {
				const currentWidth = widestLine(text);
				const maxWidth = getMaxWidth(yogaNode);

				if (currentWidth > maxWidth) {
					const textWrap = node.style.textWrap ?? 'wrap';
					text = wrapText(text, maxWidth, textWrap);
				}

				text = applyPaddingToText(node, text);

				output.write(x, y, text, {transformers: newTransformers});
			}

			return;
		}

		let clipped = false;

		if (node.nodeName === 'ink-box') {
			renderBackground(x, y, node, output);
			renderBorder(x, y, node, output);

			const clipHorizontally =
				node.style.overflowX === 'hidden' || node.style.overflow === 'hidden';
			const clipVertically =
				node.style.overflowY === 'hidden' || node.style.overflow === 'hidden';

			if (clipHorizontally || clipVertically) {
				const x1 = clipHorizontally
					? x + yogaNode.getComputedBorder(Yoga.EDGE_LEFT)
					: undefined;

				const x2 = clipHorizontally
					? x +
						yogaNode.getComputedWidth() -
						yogaNode.getComputedBorder(Yoga.EDGE_RIGHT)
					: undefined;

				const y1 = clipVertically
					? y + yogaNode.getComputedBorder(Yoga.EDGE_TOP)
					: undefined;

				const y2 = clipVertically
					? y +
						yogaNode.getComputedHeight() -
						yogaNode.getComputedBorder(Yoga.EDGE_BOTTOM)
					: undefined;

				output.clip({x1, x2, y1, y2});
				clipped = true;
			}
		}

		if (node.nodeName === 'ink-root' || node.nodeName === 'ink-box') {
			for (const childNode of node.childNodes) {
				renderNodeToOutput(childNode as DOMElement, output, {
					offsetX: x,
					offsetY: y,
					transformers: newTransformers,
					skipStaticElements,
				});
			}

			if (clipped) {
				output.unclip();
			}
		}
	}
};

export default renderNodeToOutput;



================================================
FILE: src/render.ts
================================================
import {Stream} from 'node:stream';
import process from 'node:process';
import type {ReactNode} from 'react';
import Ink, {type Options as InkOptions, type RenderMetrics} from './ink.js';
import instances from './instances.js';

export type RenderOptions = {
	/**
	Output stream where app will be rendered.

	@default process.stdout
	*/
	stdout?: NodeJS.WriteStream;

	/**
	Input stream where app will listen for input.

	@default process.stdin
	*/
	stdin?: NodeJS.ReadStream;

	/**
	Error stream.
	@default process.stderr
	*/
	stderr?: NodeJS.WriteStream;

	/**
	If true, each update will be rendered as separate output, without replacing the previous one.

	@default false
	*/
	debug?: boolean;

	/**
	Configure whether Ink should listen for Ctrl+C keyboard input and exit the app. This is needed in case `process.stdin` is in raw mode, because then Ctrl+C is ignored by default and the process is expected to handle it manually.

	@default true
	*/
	exitOnCtrlC?: boolean;

	/**
	Patch console methods to ensure console output doesn't mix with Ink's output.

	@default true
	*/
	patchConsole?: boolean;

	/**
	Runs the given callback after each render and re-render.
	*/
	onRender?: (metrics: RenderMetrics) => void;

	/**
	Enable screen reader support. See https://github.com/vadimdemedes/ink/blob/master/readme.md#screen-reader-support

	@default process.env['INK_SCREEN_READER'] === 'true'
	*/
	isScreenReaderEnabled?: boolean;

	/**
	Maximum frames per second for render updates.
	This controls how frequently the UI can update to prevent excessive re-rendering.
	Higher values allow more frequent updates but may impact performance.

	@default 30
	*/
	maxFps?: number;
};

export type Instance = {
	/**
	Replace the previous root node with a new one or update props of the current root node.
	*/
	rerender: Ink['render'];

	/**
	Manually unmount the whole Ink app.
	*/
	unmount: Ink['unmount'];

	/**
	Returns a promise that resolves when the app is unmounted.
	*/
	waitUntilExit: Ink['waitUntilExit'];

	cleanup: () => void;

	/**
	Clear output.
	*/
	clear: () => void;
};

/**
Mount a component and render the output.
*/
const render = (
	node: ReactNode,
	options?: NodeJS.WriteStream | RenderOptions,
): Instance => {
	const inkOptions: InkOptions = {
		stdout: process.stdout,
		stdin: process.stdin,
		stderr: process.stderr,
		debug: false,
		exitOnCtrlC: true,
		patchConsole: true,
		maxFps: 30,
		...getOptions(options),
	};

	const instance: Ink = getInstance(
		inkOptions.stdout,
		() => new Ink(inkOptions),
	);

	instance.render(node);

	return {
		rerender: instance.render,
		unmount() {
			instance.unmount();
		},
		waitUntilExit: instance.waitUntilExit,
		cleanup: () => instances.delete(inkOptions.stdout),
		clear: instance.clear,
	};
};

export default render;

const getOptions = (
	stdout: NodeJS.WriteStream | RenderOptions | undefined = {},
): RenderOptions => {
	if (stdout instanceof Stream) {
		return {
			stdout,
			stdin: process.stdin,
		};
	}

	return stdout;
};

const getInstance = (
	stdout: NodeJS.WriteStream,
	createInstance: () => Ink,
): Ink => {
	let instance = instances.get(stdout);

	if (!instance) {
		instance = createInstance();
		instances.set(stdout, instance);
	}

	return instance;
};



================================================
FILE: src/renderer.ts
================================================
import renderNodeToOutput, {
	renderNodeToScreenReaderOutput,
} from './render-node-to-output.js';
import Output from './output.js';
import {type DOMElement} from './dom.js';

type Result = {
	output: string;
	outputHeight: number;
	staticOutput: string;
};

const renderer = (node: DOMElement, isScreenReaderEnabled: boolean): Result => {
	if (node.yogaNode) {
		if (isScreenReaderEnabled) {
			const output = renderNodeToScreenReaderOutput(node, {
				skipStaticElements: true,
			});

			const outputHeight = output === '' ? 0 : output.split('\n').length;

			let staticOutput = '';

			if (node.staticNode) {
				staticOutput = renderNodeToScreenReaderOutput(node.staticNode, {
					skipStaticElements: false,
				});
			}

			return {
				output,
				outputHeight,
				staticOutput: staticOutput ? `${staticOutput}\n` : '',
			};
		}

		const output = new Output({
			width: node.yogaNode.getComputedWidth(),
			height: node.yogaNode.getComputedHeight(),
		});

		renderNodeToOutput(node, output, {
			skipStaticElements: true,
		});

		let staticOutput;

		if (node.staticNode?.yogaNode) {
			staticOutput = new Output({
				width: node.staticNode.yogaNode.getComputedWidth(),
				height: node.staticNode.yogaNode.getComputedHeight(),
			});

			renderNodeToOutput(node.staticNode, staticOutput, {
				skipStaticElements: false,
			});
		}

		const {output: generatedOutput, height: outputHeight} = output.get();

		return {
			output: generatedOutput,
			outputHeight,
			// Newline at the end is needed, because static output doesn't have one, so
			// interactive output will override last line of static output
			staticOutput: staticOutput ? `${staticOutput.get().output}\n` : '',
		};
	}

	return {
		output: '',
		outputHeight: 0,
		staticOutput: '',
	};
};

export default renderer;



================================================
FILE: src/squash-text-nodes.ts
================================================
import {type DOMElement} from './dom.js';

// Squashing text nodes allows to combine multiple text nodes into one and write
// to `Output` instance only once. For example, <Text>hello{' '}world</Text>
// is actually 3 text nodes, which would result 3 writes to `Output`.
//
// Also, this is necessary for libraries like ink-link (https://github.com/sindresorhus/ink-link),
// which need to wrap all children at once, instead of wrapping 3 text nodes separately.
const squashTextNodes = (node: DOMElement): string => {
	let text = '';

	for (let index = 0; index < node.childNodes.length; index++) {
		const childNode = node.childNodes[index];

		if (childNode === undefined) {
			continue;
		}

		let nodeText = '';

		if (childNode.nodeName === '#text') {
			nodeText = childNode.nodeValue;
		} else {
			if (
				childNode.nodeName === 'ink-text' ||
				childNode.nodeName === 'ink-virtual-text'
			) {
				nodeText = squashTextNodes(childNode);
			}

			// Since these text nodes are being concatenated, `Output` instance won't be able to
			// apply children transform, so we have to do it manually here for each text node
			if (
				nodeText.length > 0 &&
				typeof childNode.internal_transform === 'function'
			) {
				nodeText = childNode.internal_transform(nodeText, index);
			}
		}

		text += nodeText;
	}

	return text;
};

export default squashTextNodes;



================================================
FILE: src/styles.ts
================================================
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import {type Boxes, type BoxStyle} from 'cli-boxes';
import {type LiteralUnion} from 'type-fest';
import {type ForegroundColorName} from 'ansi-styles'; // Note: We import directly from `ansi-styles` to avoid a bug in TypeScript.
import Yoga, {type Node as YogaNode} from 'yoga-layout';

export type Styles = {
	readonly textWrap?:
		| 'wrap'
		| 'end'
		| 'middle'
		| 'truncate-end'
		| 'truncate'
		| 'truncate-middle'
		| 'truncate-start';

	readonly position?: 'absolute' | 'relative';

	/**
	Size of the gap between an element's columns.
	*/
	readonly columnGap?: number;

	/**
	Size of the gap between an element's rows.
	*/
	readonly rowGap?: number;

	/**
	Size of the gap between an element's columns and rows. A shorthand for `columnGap` and `rowGap`.
	*/
	readonly gap?: number;

	/**
	Margin on all sides. Equivalent to setting `marginTop`, `marginBottom`, `marginLeft`, and `marginRight`.
	*/
	readonly margin?: number;

	/**
	Horizontal margin. Equivalent to setting `marginLeft` and `marginRight`.
	*/
	readonly marginX?: number;

	/**
	Vertical margin. Equivalent to setting `marginTop` and `marginBottom`.
	*/
	readonly marginY?: number;

	/**
	Top margin.
	*/
	readonly marginTop?: number;

	/**
	Bottom margin.
	*/
	readonly marginBottom?: number;

	/**
	Left margin.
	*/
	readonly marginLeft?: number;

	/**
	Right margin.
	*/
	readonly marginRight?: number;

	/**
	Padding on all sides. Equivalent to setting `paddingTop`, `paddingBottom`, `paddingLeft`, and `paddingRight`.
	*/
	readonly padding?: number;

	/**
	Horizontal padding. Equivalent to setting `paddingLeft` and `paddingRight`.
	*/
	readonly paddingX?: number;

	/**
	Vertical padding. Equivalent to setting `paddingTop` and `paddingBottom`.
	*/
	readonly paddingY?: number;

	/**
	Top padding.
	*/
	readonly paddingTop?: number;

	/**
	Bottom padding.
	*/
	readonly paddingBottom?: number;

	/**
	Left padding.
	*/
	readonly paddingLeft?: number;

	/**
	Right padding.
	*/
	readonly paddingRight?: number;

	/**
	This property defines the ability for a flex item to grow if necessary.
	See [flex-grow](https://css-tricks.com/almanac/properties/f/flex-grow/).
	*/
	readonly flexGrow?: number;

	/**
	It specifies the “flex shrink factor”, which determines how much the flex item will shrink relative to the rest of the flex items in the flex container when there isn’t enough space on the row.
	See [flex-shrink](https://css-tricks.com/almanac/properties/f/flex-shrink/).
	*/
	readonly flexShrink?: number;

	/**
	It establishes the main-axis, thus defining the direction flex items are placed in the flex container.
	See [flex-direction](https://css-tricks.com/almanac/properties/f/flex-direction/).
	*/
	readonly flexDirection?: 'row' | 'column' | 'row-reverse' | 'column-reverse';

	/**
	It specifies the initial size of the flex item, before any available space is distributed according to the flex factors.
	See [flex-basis](https://css-tricks.com/almanac/properties/f/flex-basis/).
	*/
	readonly flexBasis?: number | string;

	/**
	It defines whether the flex items are forced in a single line or can be flowed into multiple lines. If set to multiple lines, it also defines the cross-axis which determines the direction new lines are stacked in.
	See [flex-wrap](https://css-tricks.com/almanac/properties/f/flex-wrap/).
	*/
	readonly flexWrap?: 'nowrap' | 'wrap' | 'wrap-reverse';

	/**
	The align-items property defines the default behavior for how items are laid out along the cross axis (perpendicular to the main axis).
	See [align-items](https://css-tricks.com/almanac/properties/a/align-items/).
	*/
	readonly alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';

	/**
	It makes possible to override the align-items value for specific flex items.
	See [align-self](https://css-tricks.com/almanac/properties/a/align-self/).
	*/
	readonly alignSelf?: 'flex-start' | 'center' | 'flex-end' | 'auto';

	/**
	It defines the alignment along the main axis.
	See [justify-content](https://css-tricks.com/almanac/properties/j/justify-content/).
	*/
	readonly justifyContent?:
		| 'flex-start'
		| 'flex-end'
		| 'space-between'
		| 'space-around'
		| 'space-evenly'
		| 'center';

	/**
	Width of the element in spaces. You can also set it as a percentage, which will calculate the width based on the width of the parent element.
	*/
	readonly width?: number | string;

	/**
	Height of the element in lines (rows). You can also set it as a percentage, which will calculate the height based on the height of the parent element.
	*/
	readonly height?: number | string;

	/**
	Sets a minimum width of the element.
	*/
	readonly minWidth?: number | string;

	/**
	Sets a minimum height of the element.
	*/
	readonly minHeight?: number | string;

	/**
	Set this property to `none` to hide the element.
	*/
	readonly display?: 'flex' | 'none';

	/**
	Add a border with a specified style. If `borderStyle` is `undefined` (the default), no border will be added.
	*/
	readonly borderStyle?: keyof Boxes | BoxStyle;

	/**
	Determines whether top border is visible.
	
	@default true
	*/
	readonly borderTop?: boolean;

	/**
	Determines whether bottom border is visible.
	
	@default true
	*/
	readonly borderBottom?: boolean;

	/**
	Determines whether left border is visible.
	
	@default true
	*/
	readonly borderLeft?: boolean;

	/**
	Determines whether right border is visible.
	
	@default true
	*/
	readonly borderRight?: boolean;

	/**
	Change border color. A shorthand for setting `borderTopColor`, `borderRightColor`, `borderBottomColor`, and `borderLeftColor`.
	*/
	readonly borderColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Change top border color. Accepts the same values as `color` in `Text` component.
	*/
	readonly borderTopColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Change bottom border color. Accepts the same values as `color` in `Text` component.
	*/
	readonly borderBottomColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Change left border color. Accepts the same values as `color` in `Text` component.
	*/
	readonly borderLeftColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Change right border color. Accepts the same values as `color` in `Text` component.
	*/
	readonly borderRightColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Dim the border color. A shorthand for setting `borderTopDimColor`, `borderBottomDimColor`, `borderLeftDimColor`, and `borderRightDimColor`.

	@default false
	*/
	readonly borderDimColor?: boolean;

	/**
	Dim the top border color.
	
	@default false
	*/
	readonly borderTopDimColor?: boolean;

	/**
	Dim the bottom border color.
	
	@default false
	*/
	readonly borderBottomDimColor?: boolean;

	/**
	Dim the left border color.
	
	@default false
	*/
	readonly borderLeftDimColor?: boolean;

	/**
	Dim the right border color.
	
	@default false
	*/
	readonly borderRightDimColor?: boolean;

	/**
	Behavior for an element's overflow in both directions.
	
	@default 'visible'
	*/
	readonly overflow?: 'visible' | 'hidden';

	/**
	Behavior for an element's overflow in the horizontal direction.

	@default 'visible'
	*/
	readonly overflowX?: 'visible' | 'hidden';

	/**
	Behavior for an element's overflow in the vertical direction.

	@default 'visible'
	*/
	readonly overflowY?: 'visible' | 'hidden';

	/**
	Background color for the element.
	
	Accepts the same values as `color` in the `<Text>` component.
	*/
	readonly backgroundColor?: LiteralUnion<ForegroundColorName, string>;
};

const applyPositionStyles = (node: YogaNode, style: Styles): void => {
	if ('position' in style) {
		node.setPositionType(
			style.position === 'absolute'
				? Yoga.POSITION_TYPE_ABSOLUTE
				: Yoga.POSITION_TYPE_RELATIVE,
		);
	}
};

const applyMarginStyles = (node: YogaNode, style: Styles): void => {
	if ('margin' in style) {
		node.setMargin(Yoga.EDGE_ALL, style.margin ?? 0);
	}

	if ('marginX' in style) {
		node.setMargin(Yoga.EDGE_HORIZONTAL, style.marginX ?? 0);
	}

	if ('marginY' in style) {
		node.setMargin(Yoga.EDGE_VERTICAL, style.marginY ?? 0);
	}

	if ('marginLeft' in style) {
		node.setMargin(Yoga.EDGE_START, style.marginLeft || 0);
	}

	if ('marginRight' in style) {
		node.setMargin(Yoga.EDGE_END, style.marginRight || 0);
	}

	if ('marginTop' in style) {
		node.setMargin(Yoga.EDGE_TOP, style.marginTop || 0);
	}

	if ('marginBottom' in style) {
		node.setMargin(Yoga.EDGE_BOTTOM, style.marginBottom || 0);
	}
};

const applyPaddingStyles = (node: YogaNode, style: Styles): void => {
	if ('padding' in style) {
		node.setPadding(Yoga.EDGE_ALL, style.padding ?? 0);
	}

	if ('paddingX' in style) {
		node.setPadding(Yoga.EDGE_HORIZONTAL, style.paddingX ?? 0);
	}

	if ('paddingY' in style) {
		node.setPadding(Yoga.EDGE_VERTICAL, style.paddingY ?? 0);
	}

	if ('paddingLeft' in style) {
		node.setPadding(Yoga.EDGE_LEFT, style.paddingLeft || 0);
	}

	if ('paddingRight' in style) {
		node.setPadding(Yoga.EDGE_RIGHT, style.paddingRight || 0);
	}

	if ('paddingTop' in style) {
		node.setPadding(Yoga.EDGE_TOP, style.paddingTop || 0);
	}

	if ('paddingBottom' in style) {
		node.setPadding(Yoga.EDGE_BOTTOM, style.paddingBottom || 0);
	}
};

const applyFlexStyles = (node: YogaNode, style: Styles): void => {
	if ('flexGrow' in style) {
		node.setFlexGrow(style.flexGrow ?? 0);
	}

	if ('flexShrink' in style) {
		node.setFlexShrink(
			typeof style.flexShrink === 'number' ? style.flexShrink : 1,
		);
	}

	if ('flexWrap' in style) {
		if (style.flexWrap === 'nowrap') {
			node.setFlexWrap(Yoga.WRAP_NO_WRAP);
		}

		if (style.flexWrap === 'wrap') {
			node.setFlexWrap(Yoga.WRAP_WRAP);
		}

		if (style.flexWrap === 'wrap-reverse') {
			node.setFlexWrap(Yoga.WRAP_WRAP_REVERSE);
		}
	}

	if ('flexDirection' in style) {
		if (style.flexDirection === 'row') {
			node.setFlexDirection(Yoga.FLEX_DIRECTION_ROW);
		}

		if (style.flexDirection === 'row-reverse') {
			node.setFlexDirection(Yoga.FLEX_DIRECTION_ROW_REVERSE);
		}

		if (style.flexDirection === 'column') {
			node.setFlexDirection(Yoga.FLEX_DIRECTION_COLUMN);
		}

		if (style.flexDirection === 'column-reverse') {
			node.setFlexDirection(Yoga.FLEX_DIRECTION_COLUMN_REVERSE);
		}
	}

	if ('flexBasis' in style) {
		if (typeof style.flexBasis === 'number') {
			node.setFlexBasis(style.flexBasis);
		} else if (typeof style.flexBasis === 'string') {
			node.setFlexBasisPercent(Number.parseInt(style.flexBasis, 10));
		} else {
			// This should be replaced with node.setFlexBasisAuto() when new Yoga release is out
			node.setFlexBasis(Number.NaN);
		}
	}

	if ('alignItems' in style) {
		if (style.alignItems === 'stretch' || !style.alignItems) {
			node.setAlignItems(Yoga.ALIGN_STRETCH);
		}

		if (style.alignItems === 'flex-start') {
			node.setAlignItems(Yoga.ALIGN_FLEX_START);
		}

		if (style.alignItems === 'center') {
			node.setAlignItems(Yoga.ALIGN_CENTER);
		}

		if (style.alignItems === 'flex-end') {
			node.setAlignItems(Yoga.ALIGN_FLEX_END);
		}
	}

	if ('alignSelf' in style) {
		if (style.alignSelf === 'auto' || !style.alignSelf) {
			node.setAlignSelf(Yoga.ALIGN_AUTO);
		}

		if (style.alignSelf === 'flex-start') {
			node.setAlignSelf(Yoga.ALIGN_FLEX_START);
		}

		if (style.alignSelf === 'center') {
			node.setAlignSelf(Yoga.ALIGN_CENTER);
		}

		if (style.alignSelf === 'flex-end') {
			node.setAlignSelf(Yoga.ALIGN_FLEX_END);
		}
	}

	if ('justifyContent' in style) {
		if (style.justifyContent === 'flex-start' || !style.justifyContent) {
			node.setJustifyContent(Yoga.JUSTIFY_FLEX_START);
		}

		if (style.justifyContent === 'center') {
			node.setJustifyContent(Yoga.JUSTIFY_CENTER);
		}

		if (style.justifyContent === 'flex-end') {
			node.setJustifyContent(Yoga.JUSTIFY_FLEX_END);
		}

		if (style.justifyContent === 'space-between') {
			node.setJustifyContent(Yoga.JUSTIFY_SPACE_BETWEEN);
		}

		if (style.justifyContent === 'space-around') {
			node.setJustifyContent(Yoga.JUSTIFY_SPACE_AROUND);
		}

		if (style.justifyContent === 'space-evenly') {
			node.setJustifyContent(Yoga.JUSTIFY_SPACE_EVENLY);
		}
	}
};

const applyDimensionStyles = (node: YogaNode, style: Styles): void => {
	if ('width' in style) {
		if (typeof style.width === 'number') {
			node.setWidth(style.width);
		} else if (typeof style.width === 'string') {
			node.setWidthPercent(Number.parseInt(style.width, 10));
		} else {
			node.setWidthAuto();
		}
	}

	if ('height' in style) {
		if (typeof style.height === 'number') {
			node.setHeight(style.height);
		} else if (typeof style.height === 'string') {
			node.setHeightPercent(Number.parseInt(style.height, 10));
		} else {
			node.setHeightAuto();
		}
	}

	if ('minWidth' in style) {
		if (typeof style.minWidth === 'string') {
			node.setMinWidthPercent(Number.parseInt(style.minWidth, 10));
		} else {
			node.setMinWidth(style.minWidth ?? 0);
		}
	}

	if ('minHeight' in style) {
		if (typeof style.minHeight === 'string') {
			node.setMinHeightPercent(Number.parseInt(style.minHeight, 10));
		} else {
			node.setMinHeight(style.minHeight ?? 0);
		}
	}
};

const applyDisplayStyles = (node: YogaNode, style: Styles): void => {
	if ('display' in style) {
		node.setDisplay(
			style.display === 'flex' ? Yoga.DISPLAY_FLEX : Yoga.DISPLAY_NONE,
		);
	}
};

const applyBorderStyles = (node: YogaNode, style: Styles): void => {
	if ('borderStyle' in style) {
		const borderWidth = style.borderStyle ? 1 : 0;

		if (style.borderTop !== false) {
			node.setBorder(Yoga.EDGE_TOP, borderWidth);
		}

		if (style.borderBottom !== false) {
			node.setBorder(Yoga.EDGE_BOTTOM, borderWidth);
		}

		if (style.borderLeft !== false) {
			node.setBorder(Yoga.EDGE_LEFT, borderWidth);
		}

		if (style.borderRight !== false) {
			node.setBorder(Yoga.EDGE_RIGHT, borderWidth);
		}
	}
};

const applyGapStyles = (node: YogaNode, style: Styles): void => {
	if ('gap' in style) {
		node.setGap(Yoga.GUTTER_ALL, style.gap ?? 0);
	}

	if ('columnGap' in style) {
		node.setGap(Yoga.GUTTER_COLUMN, style.columnGap ?? 0);
	}

	if ('rowGap' in style) {
		node.setGap(Yoga.GUTTER_ROW, style.rowGap ?? 0);
	}
};

const styles = (node: YogaNode, style: Styles = {}): void => {
	applyPositionStyles(node, style);
	applyMarginStyles(node, style);
	applyPaddingStyles(node, style);
	applyFlexStyles(node, style);
	applyDimensionStyles(node, style);
	applyDisplayStyles(node, style);
	applyBorderStyles(node, style);
	applyGapStyles(node, style);
};

export default styles;



================================================
FILE: src/wrap-text.ts
================================================
import wrapAnsi from 'wrap-ansi';
import cliTruncate from 'cli-truncate';
import {type Styles} from './styles.js';

const cache: Record<string, string> = {};

const wrapText = (
	text: string,
	maxWidth: number,
	wrapType: Styles['textWrap'],
): string => {
	const cacheKey = text + String(maxWidth) + String(wrapType);
	const cachedText = cache[cacheKey];

	if (cachedText) {
		return cachedText;
	}

	let wrappedText = text;

	if (wrapType === 'wrap') {
		wrappedText = wrapAnsi(text, maxWidth, {
			trim: false,
			hard: true,
		});
	}

	if (wrapType!.startsWith('truncate')) {
		let position: 'end' | 'middle' | 'start' = 'end';

		if (wrapType === 'truncate-middle') {
			position = 'middle';
		}

		if (wrapType === 'truncate-start') {
			position = 'start';
		}

		wrappedText = cliTruncate(text, maxWidth, {position});
	}

	cache[cacheKey] = wrappedText;

	return wrappedText;
};

export default wrapText;



================================================
FILE: src/components/AccessibilityContext.ts
================================================
import {createContext} from 'react';

export const accessibilityContext = createContext({
	isScreenReaderEnabled: false,
});



================================================
FILE: src/components/App.tsx
================================================
import {EventEmitter} from 'node:events';
import process from 'node:process';
import React, {PureComponent, type ReactNode} from 'react';
import cliCursor from 'cli-cursor';
import AppContext from './AppContext.js';
import StdinContext from './StdinContext.js';
import StdoutContext from './StdoutContext.js';
import StderrContext from './StderrContext.js';
import FocusContext from './FocusContext.js';
import ErrorOverview from './ErrorOverview.js';

const tab = '\t';
const shiftTab = '\u001B[Z';
const escape = '\u001B';

type Props = {
	readonly children: ReactNode;
	readonly stdin: NodeJS.ReadStream;
	readonly stdout: NodeJS.WriteStream;
	readonly stderr: NodeJS.WriteStream;
	readonly writeToStdout: (data: string) => void;
	readonly writeToStderr: (data: string) => void;
	readonly exitOnCtrlC: boolean;
	readonly onExit: (error?: Error) => void;
};

type State = {
	readonly isFocusEnabled: boolean;
	readonly activeFocusId?: string;
	readonly focusables: Focusable[];
	readonly error?: Error;
};

type Focusable = {
	readonly id: string;
	readonly isActive: boolean;
};

// Root component for all Ink apps
// It renders stdin and stdout contexts, so that children can access them if needed
// It also handles Ctrl+C exiting and cursor visibility
export default class App extends PureComponent<Props, State> {
	static displayName = 'InternalApp';

	static getDerivedStateFromError(error: Error) {
		return {error};
	}

	override state = {
		isFocusEnabled: true,
		activeFocusId: undefined,
		focusables: [],
		error: undefined,
	};

	// Count how many components enabled raw mode to avoid disabling
	// raw mode until all components don't need it anymore
	rawModeEnabledCount = 0;
	// eslint-disable-next-line @typescript-eslint/naming-convention
	internal_eventEmitter = new EventEmitter();

	// Determines if TTY is supported on the provided stdin
	isRawModeSupported(): boolean {
		return this.props.stdin.isTTY;
	}

	override render() {
		return (
			<AppContext.Provider
				// eslint-disable-next-line react/jsx-no-constructed-context-values
				value={{
					exit: this.handleExit,
				}}
			>
				<StdinContext.Provider
					// eslint-disable-next-line react/jsx-no-constructed-context-values
					value={{
						stdin: this.props.stdin,
						setRawMode: this.handleSetRawMode,
						isRawModeSupported: this.isRawModeSupported(),
						// eslint-disable-next-line @typescript-eslint/naming-convention
						internal_exitOnCtrlC: this.props.exitOnCtrlC,
						// eslint-disable-next-line @typescript-eslint/naming-convention
						internal_eventEmitter: this.internal_eventEmitter,
					}}
				>
					<StdoutContext.Provider
						// eslint-disable-next-line react/jsx-no-constructed-context-values
						value={{
							stdout: this.props.stdout,
							write: this.props.writeToStdout,
						}}
					>
						<StderrContext.Provider
							// eslint-disable-next-line react/jsx-no-constructed-context-values
							value={{
								stderr: this.props.stderr,
								write: this.props.writeToStderr,
							}}
						>
							<FocusContext.Provider
								// eslint-disable-next-line react/jsx-no-constructed-context-values
								value={{
									activeId: this.state.activeFocusId,
									add: this.addFocusable,
									remove: this.removeFocusable,
									activate: this.activateFocusable,
									deactivate: this.deactivateFocusable,
									enableFocus: this.enableFocus,
									disableFocus: this.disableFocus,
									focusNext: this.focusNext,
									focusPrevious: this.focusPrevious,
									focus: this.focus,
								}}
							>
								{this.state.error ? (
									<ErrorOverview error={this.state.error as Error} />
								) : (
									this.props.children
								)}
							</FocusContext.Provider>
						</StderrContext.Provider>
					</StdoutContext.Provider>
				</StdinContext.Provider>
			</AppContext.Provider>
		);
	}

	override componentDidMount() {
		cliCursor.hide(this.props.stdout);
	}

	override componentWillUnmount() {
		cliCursor.show(this.props.stdout);

		// ignore calling setRawMode on an handle stdin it cannot be called
		if (this.isRawModeSupported()) {
			this.handleSetRawMode(false);
		}
	}

	override componentDidCatch(error: Error) {
		this.handleExit(error);
	}

	handleSetRawMode = (isEnabled: boolean): void => {
		const {stdin} = this.props;

		if (!this.isRawModeSupported()) {
			if (stdin === process.stdin) {
				throw new Error(
					'Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported',
				);
			} else {
				throw new Error(
					'Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported',
				);
			}
		}

		stdin.setEncoding('utf8');

		if (isEnabled) {
			// Ensure raw mode is enabled only once
			if (this.rawModeEnabledCount === 0) {
				stdin.ref();
				stdin.setRawMode(true);
				stdin.addListener('readable', this.handleReadable);
			}

			this.rawModeEnabledCount++;
			return;
		}

		// Disable raw mode only when no components left that are using it
		if (--this.rawModeEnabledCount === 0) {
			stdin.setRawMode(false);
			stdin.removeListener('readable', this.handleReadable);
			stdin.unref();
		}
	};

	handleReadable = (): void => {
		let chunk;
		// eslint-disable-next-line @typescript-eslint/ban-types
		while ((chunk = this.props.stdin.read() as string | null) !== null) {
			this.handleInput(chunk);
			this.internal_eventEmitter.emit('input', chunk);
		}
	};

	handleInput = (input: string): void => {
		// Exit on Ctrl+C
		// eslint-disable-next-line unicorn/no-hex-escape
		if (input === '\x03' && this.props.exitOnCtrlC) {
			this.handleExit();
		}

		// Reset focus when there's an active focused component on Esc
		if (input === escape && this.state.activeFocusId) {
			this.setState({
				activeFocusId: undefined,
			});
		}

		if (this.state.isFocusEnabled && this.state.focusables.length > 0) {
			if (input === tab) {
				this.focusNext();
			}

			if (input === shiftTab) {
				this.focusPrevious();
			}
		}
	};

	handleExit = (error?: Error): void => {
		if (this.isRawModeSupported()) {
			this.handleSetRawMode(false);
		}

		this.props.onExit(error);
	};

	enableFocus = (): void => {
		this.setState({
			isFocusEnabled: true,
		});
	};

	disableFocus = (): void => {
		this.setState({
			isFocusEnabled: false,
		});
	};

	focus = (id: string): void => {
		this.setState(previousState => {
			const hasFocusableId = previousState.focusables.some(
				focusable => focusable?.id === id,
			);

			if (!hasFocusableId) {
				return previousState;
			}

			return {activeFocusId: id};
		});
	};

	focusNext = (): void => {
		this.setState(previousState => {
			const firstFocusableId = previousState.focusables.find(
				focusable => focusable.isActive,
			)?.id;
			const nextFocusableId = this.findNextFocusable(previousState);

			return {
				activeFocusId: nextFocusableId ?? firstFocusableId,
			};
		});
	};

	focusPrevious = (): void => {
		this.setState(previousState => {
			const lastFocusableId = previousState.focusables.findLast(
				focusable => focusable.isActive,
			)?.id;
			const previousFocusableId = this.findPreviousFocusable(previousState);

			return {
				activeFocusId: previousFocusableId ?? lastFocusableId,
			};
		});
	};

	addFocusable = (id: string, {autoFocus}: {autoFocus: boolean}): void => {
		this.setState(previousState => {
			let nextFocusId = previousState.activeFocusId;

			if (!nextFocusId && autoFocus) {
				nextFocusId = id;
			}

			return {
				activeFocusId: nextFocusId,
				focusables: [
					...previousState.focusables,
					{
						id,
						isActive: true,
					},
				],
			};
		});
	};

	removeFocusable = (id: string): void => {
		this.setState(previousState => ({
			activeFocusId:
				previousState.activeFocusId === id
					? undefined
					: previousState.activeFocusId,
			focusables: previousState.focusables.filter(focusable => {
				return focusable.id !== id;
			}),
		}));
	};

	activateFocusable = (id: string): void => {
		this.setState(previousState => ({
			focusables: previousState.focusables.map(focusable => {
				if (focusable.id !== id) {
					return focusable;
				}

				return {
					id,
					isActive: true,
				};
			}),
		}));
	};

	deactivateFocusable = (id: string): void => {
		this.setState(previousState => ({
			activeFocusId:
				previousState.activeFocusId === id
					? undefined
					: previousState.activeFocusId,
			focusables: previousState.focusables.map(focusable => {
				if (focusable.id !== id) {
					return focusable;
				}

				return {
					id,
					isActive: false,
				};
			}),
		}));
	};

	findNextFocusable = (state: State): string | undefined => {
		const activeIndex = state.focusables.findIndex(focusable => {
			return focusable.id === state.activeFocusId;
		});

		for (
			let index = activeIndex + 1;
			index < state.focusables.length;
			index++
		) {
			const focusable = state.focusables[index];

			if (focusable?.isActive) {
				return focusable.id;
			}
		}

		return undefined;
	};

	findPreviousFocusable = (state: State): string | undefined => {
		const activeIndex = state.focusables.findIndex(focusable => {
			return focusable.id === state.activeFocusId;
		});

		for (let index = activeIndex - 1; index >= 0; index--) {
			const focusable = state.focusables[index];

			if (focusable?.isActive) {
				return focusable.id;
			}
		}

		return undefined;
	};
}



================================================
FILE: src/components/AppContext.ts
================================================
import {createContext} from 'react';

export type Props = {
	/**
	Exit (unmount) the whole Ink app.
	*/
	readonly exit: (error?: Error) => void;
};

/**
`AppContext` is a React context that exposes a method to manually exit the app (unmount).
*/
// eslint-disable-next-line @typescript-eslint/naming-convention
const AppContext = createContext<Props>({
	exit() {},
});

AppContext.displayName = 'InternalAppContext';

export default AppContext;



================================================
FILE: src/components/BackgroundContext.ts
================================================
import {createContext} from 'react';
import {type LiteralUnion} from 'type-fest';
import {type ForegroundColorName} from 'ansi-styles';

export type BackgroundColor = LiteralUnion<ForegroundColorName, string>;

export const backgroundContext = createContext<BackgroundColor | undefined>(
	undefined,
);



================================================
FILE: src/components/Box.tsx
================================================
import React, {forwardRef, useContext, type PropsWithChildren} from 'react';
import {type Except} from 'type-fest';
import {type Styles} from '../styles.js';
import {type DOMElement} from '../dom.js';
import {accessibilityContext} from './AccessibilityContext.js';
import {backgroundContext} from './BackgroundContext.js';

export type Props = Except<Styles, 'textWrap'> & {
	/**
	A label for the element for screen readers.
	*/
	readonly 'aria-label'?: string;

	/**
	Hide the element from screen readers.
	*/
	readonly 'aria-hidden'?: boolean;

	/**
	The role of the element.
	*/
	readonly 'aria-role'?:
		| 'button'
		| 'checkbox'
		| 'combobox'
		| 'list'
		| 'listbox'
		| 'listitem'
		| 'menu'
		| 'menuitem'
		| 'option'
		| 'progressbar'
		| 'radio'
		| 'radiogroup'
		| 'tab'
		| 'tablist'
		| 'table'
		| 'textbox'
		| 'timer'
		| 'toolbar';

	/**
	The state of the element.
	*/
	readonly 'aria-state'?: {
		readonly busy?: boolean;
		readonly checked?: boolean;
		readonly disabled?: boolean;
		readonly expanded?: boolean;
		readonly multiline?: boolean;
		readonly multiselectable?: boolean;
		readonly readonly?: boolean;
		readonly required?: boolean;
		readonly selected?: boolean;
	};
};

/**
`<Box>` is an essential Ink component to build your layout. It's like `<div style="display: flex">` in the browser.
*/
const Box = forwardRef<DOMElement, PropsWithChildren<Props>>(
	(
		{
			children,
			backgroundColor,
			'aria-label': ariaLabel,
			'aria-hidden': ariaHidden,
			'aria-role': role,
			'aria-state': ariaState,
			...style
		},
		ref,
	) => {
		const {isScreenReaderEnabled} = useContext(accessibilityContext);
		const label = ariaLabel ? <ink-text>{ariaLabel}</ink-text> : undefined;
		if (isScreenReaderEnabled && ariaHidden) {
			return null;
		}

		const boxElement = (
			<ink-box
				ref={ref}
				style={{
					flexWrap: 'nowrap',
					flexDirection: 'row',
					flexGrow: 0,
					flexShrink: 1,
					...style,
					backgroundColor,
					overflowX: style.overflowX ?? style.overflow ?? 'visible',
					overflowY: style.overflowY ?? style.overflow ?? 'visible',
				}}
				internal_accessibility={{
					role,
					state: ariaState,
				}}
			>
				{isScreenReaderEnabled && label ? label : children}
			</ink-box>
		);

		// If this Box has a background color, provide it to children via context
		if (backgroundColor) {
			return (
				<backgroundContext.Provider value={backgroundColor}>
					{boxElement}
				</backgroundContext.Provider>
			);
		}

		return boxElement;
	},
);

Box.displayName = 'Box';

export default Box;



================================================
FILE: src/components/ErrorOverview.tsx
================================================
import * as fs from 'node:fs';
import {cwd} from 'node:process';
import React from 'react';
import StackUtils from 'stack-utils';
import codeExcerpt, {type CodeExcerpt} from 'code-excerpt';
import Box from './Box.js';
import Text from './Text.js';

// Error's source file is reported as file:///home/user/file.js
// This function removes the file://[cwd] part
const cleanupPath = (path: string | undefined): string | undefined => {
	return path?.replace(`file://${cwd()}/`, '');
};

const stackUtils = new StackUtils({
	cwd: cwd(),
	internals: StackUtils.nodeInternals(),
});

type Props = {
	readonly error: Error;
};

export default function ErrorOverview({error}: Props) {
	const stack = error.stack ? error.stack.split('\n').slice(1) : undefined;
	const origin = stack ? stackUtils.parseLine(stack[0]!) : undefined;
	const filePath = cleanupPath(origin?.file);
	let excerpt: CodeExcerpt[] | undefined;
	let lineWidth = 0;

	if (filePath && origin?.line && fs.existsSync(filePath)) {
		const sourceCode = fs.readFileSync(filePath, 'utf8');
		excerpt = codeExcerpt(sourceCode, origin.line);

		if (excerpt) {
			for (const {line} of excerpt) {
				lineWidth = Math.max(lineWidth, String(line).length);
			}
		}
	}

	return (
		<Box flexDirection="column" padding={1}>
			<Box>
				<Text backgroundColor="red" color="white">
					{' '}
					ERROR{' '}
				</Text>

				<Text> {error.message}</Text>
			</Box>

			{origin && filePath && (
				<Box marginTop={1}>
					<Text dimColor>
						{filePath}:{origin.line}:{origin.column}
					</Text>
				</Box>
			)}

			{origin && excerpt && (
				<Box marginTop={1} flexDirection="column">
					{excerpt.map(({line, value}) => (
						<Box key={line}>
							<Box width={lineWidth + 1}>
								<Text
									dimColor={line !== origin.line}
									backgroundColor={line === origin.line ? 'red' : undefined}
									color={line === origin.line ? 'white' : undefined}
									aria-label={
										line === origin.line
											? `Line ${line}, error`
											: `Line ${line}`
									}
								>
									{String(line).padStart(lineWidth, ' ')}:
								</Text>
							</Box>

							<Text
								key={line}
								backgroundColor={line === origin.line ? 'red' : undefined}
								color={line === origin.line ? 'white' : undefined}
							>
								{' ' + value}
							</Text>
						</Box>
					))}
				</Box>
			)}

			{error.stack && (
				<Box marginTop={1} flexDirection="column">
					{error.stack
						.split('\n')
						.slice(1)
						.map(line => {
							const parsedLine = stackUtils.parseLine(line);

							// If the line from the stack cannot be parsed, we print out the unparsed line.
							if (!parsedLine) {
								return (
									<Box key={line}>
										<Text dimColor>- </Text>
										<Text dimColor bold>
											{line}
											\t{' '}
										</Text>
									</Box>
								);
							}

							return (
								<Box key={line}>
									<Text dimColor>- </Text>
									<Text dimColor bold>
										{parsedLine.function}
									</Text>
									<Text
										dimColor
										color="gray"
										aria-label={`at ${
											cleanupPath(parsedLine.file) ?? ''
										} line ${parsedLine.line} column ${parsedLine.column}`}
									>
										{' '}
										({cleanupPath(parsedLine.file) ?? ''}:{parsedLine.line}:
										{parsedLine.column})
									</Text>
								</Box>
							);
						})}
				</Box>
			)}
		</Box>
	);
}



================================================
FILE: src/components/FocusContext.ts
================================================
import {createContext} from 'react';

export type Props = {
	readonly activeId?: string;
	readonly add: (id: string, options: {autoFocus: boolean}) => void;
	readonly remove: (id: string) => void;
	readonly activate: (id: string) => void;
	readonly deactivate: (id: string) => void;
	readonly enableFocus: () => void;
	readonly disableFocus: () => void;
	readonly focusNext: () => void;
	readonly focusPrevious: () => void;
	readonly focus: (id: string) => void;
};

// eslint-disable-next-line @typescript-eslint/naming-convention
const FocusContext = createContext<Props>({
	activeId: undefined,
	add() {},
	remove() {},
	activate() {},
	deactivate() {},
	enableFocus() {},
	disableFocus() {},
	focusNext() {},
	focusPrevious() {},
	focus() {},
});

FocusContext.displayName = 'InternalFocusContext';

export default FocusContext;



================================================
FILE: src/components/Newline.tsx
================================================
import React from 'react';

export type Props = {
	/**
	Number of newlines to insert.

	@default 1
	*/
	readonly count?: number;
};

/**
Adds one or more newline (`\n`) characters. Must be used within `<Text>` components.
*/
export default function Newline({count = 1}: Props) {
	return <ink-text>{'\n'.repeat(count)}</ink-text>;
}



================================================
FILE: src/components/Spacer.tsx
================================================
import React from 'react';
import Box from './Box.js';

/**
A flexible space that expands along the major axis of its containing layout.

It's useful as a shortcut for filling all the available space between elements.
*/
export default function Spacer() {
	return <Box flexGrow={1} />;
}



================================================
FILE: src/components/Static.tsx
================================================
import React, {useMemo, useState, useLayoutEffect, type ReactNode} from 'react';
import {type Styles} from '../styles.js';

export type Props<T> = {
	/**
	Array of items of any type to render using the function you pass as a component child.
	*/
	readonly items: T[];

	/**
	Styles to apply to a container of child elements. See <Box> for supported properties.
	*/
	readonly style?: Styles;

	/**
	Function that is called to render every item in the `items` array. The first argument is the item itself, and the second argument is the index of that item in the `items` array. Note that a `key` must be assigned to the root component.
	*/
	readonly children: (item: T, index: number) => ReactNode;
};

/**
`<Static>` component permanently renders its output above everything else. It's useful for displaying activity like completed tasks or logs—things that don't change after they're rendered (hence the name "Static").

It's preferred to use `<Static>` for use cases like these when you can't know or control the number of items that need to be rendered.

For example, [Tap](https://github.com/tapjs/node-tap) uses `<Static>` to display a list of completed tests. [Gatsby](https://github.com/gatsbyjs/gatsby) uses it to display a list of generated pages while still displaying a live progress bar.
*/
export default function Static<T>(props: Props<T>) {
	const {items, children: render, style: customStyle} = props;
	const [index, setIndex] = useState(0);

	const itemsToRender: T[] = useMemo(() => {
		return items.slice(index);
	}, [items, index]);

	useLayoutEffect(() => {
		setIndex(items.length);
	}, [items.length]);

	const children = itemsToRender.map((item, itemIndex) => {
		return render(item, index + itemIndex);
	});

	const style: Styles = useMemo(
		() => ({
			position: 'absolute',
			flexDirection: 'column',
			...customStyle,
		}),
		[customStyle],
	);

	return (
		<ink-box internal_static style={style}>
			{children}
		</ink-box>
	);
}



================================================
FILE: src/components/StderrContext.ts
================================================
import process from 'node:process';
import {createContext} from 'react';

export type Props = {
	/**
	Stderr stream passed to `render()` in `options.stderr` or `process.stderr` by default.
	*/
	readonly stderr: NodeJS.WriteStream;

	/**
	Write any string to stderr while preserving Ink's output. It's useful when you want to display external information outside of Ink's rendering and ensure there's no conflict between the two. It's similar to `<Static>`, except it can't accept components; it only works with strings.
	*/
	readonly write: (data: string) => void;
};

/**
`StderrContext` is a React context that exposes the stderr stream.
*/
// eslint-disable-next-line @typescript-eslint/naming-convention
const StderrContext = createContext<Props>({
	stderr: process.stderr,
	write() {},
});

StderrContext.displayName = 'InternalStderrContext';

export default StderrContext;



================================================
FILE: src/components/StdinContext.ts
================================================
import {EventEmitter} from 'node:events';
import process from 'node:process';
import {createContext} from 'react';

export type Props = {
	/**
	The stdin stream passed to `render()` in `options.stdin`, or `process.stdin` by default. Useful if your app needs to handle user input.
	*/
	readonly stdin: NodeJS.ReadStream;

	/**
	Ink exposes this function via own `<StdinContext>` to be able to handle Ctrl+C, that's why you should use Ink's `setRawMode` instead of `process.stdin.setRawMode`. If the `stdin` stream passed to Ink does not support setRawMode, this function does nothing.
	*/
	readonly setRawMode: (value: boolean) => void;

	/**
	A boolean flag determining if the current `stdin` supports `setRawMode`. A component using `setRawMode` might want to use `isRawModeSupported` to nicely fall back in environments where raw mode is not supported.
	*/
	readonly isRawModeSupported: boolean;

	readonly internal_exitOnCtrlC: boolean;

	readonly internal_eventEmitter: EventEmitter;
};

/**
`StdinContext` is a React context that exposes the input stream.
*/
// eslint-disable-next-line @typescript-eslint/naming-convention
const StdinContext = createContext<Props>({
	stdin: process.stdin,
	// eslint-disable-next-line @typescript-eslint/naming-convention
	internal_eventEmitter: new EventEmitter(),
	setRawMode() {},
	isRawModeSupported: false,
	// eslint-disable-next-line @typescript-eslint/naming-convention
	internal_exitOnCtrlC: true,
});

StdinContext.displayName = 'InternalStdinContext';

export default StdinContext;



================================================
FILE: src/components/StdoutContext.ts
================================================
import process from 'node:process';
import {createContext} from 'react';

export type Props = {
	/**
	Stdout stream passed to `render()` in `options.stdout` or `process.stdout` by default.
	*/
	readonly stdout: NodeJS.WriteStream;

	/**
	Write any string to stdout while preserving Ink's output. It's useful when you want to display external information outside of Ink's rendering and ensure there's no conflict between the two. It's similar to `<Static>`, except it can't accept components; it only works with strings.
	*/
	readonly write: (data: string) => void;
};

/**
`StdoutContext` is a React context that exposes the stdout stream where Ink renders your app.
*/
// eslint-disable-next-line @typescript-eslint/naming-convention
const StdoutContext = createContext<Props>({
	stdout: process.stdout,
	write() {},
});

StdoutContext.displayName = 'InternalStdoutContext';

export default StdoutContext;



================================================
FILE: src/components/Text.tsx
================================================
import React, {useContext, type ReactNode} from 'react';
import chalk, {type ForegroundColorName} from 'chalk';
import {type LiteralUnion} from 'type-fest';
import colorize from '../colorize.js';
import {type Styles} from '../styles.js';
import {accessibilityContext} from './AccessibilityContext.js';
import {backgroundContext} from './BackgroundContext.js';

export type Props = {
	/**
	A label for the element for screen readers.
	*/
	readonly 'aria-label'?: string;

	/**
	Hide the element from screen readers.
	*/
	readonly 'aria-hidden'?: boolean;

	/**
	Change text color. Ink uses Chalk under the hood, so all its functionality is supported.
	*/
	readonly color?: LiteralUnion<ForegroundColorName, string>;

	/**
	Same as `color`, but for the background.
	*/
	readonly backgroundColor?: LiteralUnion<ForegroundColorName, string>;

	/**
	Dim the color (make it less bright).
	*/
	readonly dimColor?: boolean;

	/**
	Make the text bold.
	*/
	readonly bold?: boolean;

	/**
	Make the text italic.
	*/
	readonly italic?: boolean;

	/**
	Make the text underlined.
	*/
	readonly underline?: boolean;

	/**
	Make the text crossed out with a line.
	*/
	readonly strikethrough?: boolean;

	/**
	Inverse background and foreground colors.
	*/
	readonly inverse?: boolean;

	/**
	This property tells Ink to wrap or truncate text if its width is larger than the container. If `wrap` is passed (the default), Ink will wrap text and split it into multiple lines. If `truncate-*` is passed, Ink will truncate text instead, resulting in one line of text with the rest cut off.
	*/
	readonly wrap?: Styles['textWrap'];

	readonly children?: ReactNode;
};

/**
This component can display text and change its style to make it bold, underlined, italic, or strikethrough.
*/
export default function Text({
	color,
	backgroundColor,
	dimColor = false,
	bold = false,
	italic = false,
	underline = false,
	strikethrough = false,
	inverse = false,
	wrap = 'wrap',
	children,
	'aria-label': ariaLabel,
	'aria-hidden': ariaHidden = false,
}: Props) {
	const {isScreenReaderEnabled} = useContext(accessibilityContext);
	const inheritedBackgroundColor = useContext(backgroundContext);
	const childrenOrAriaLabel =
		isScreenReaderEnabled && ariaLabel ? ariaLabel : children;

	if (childrenOrAriaLabel === undefined || childrenOrAriaLabel === null) {
		return null;
	}

	const transform = (children: string): string => {
		if (dimColor) {
			children = chalk.dim(children);
		}

		if (color) {
			children = colorize(children, color, 'foreground');
		}

		// Use explicit backgroundColor if provided, otherwise use inherited from parent Box
		const effectiveBackgroundColor =
			backgroundColor ?? inheritedBackgroundColor;
		if (effectiveBackgroundColor) {
			children = colorize(children, effectiveBackgroundColor, 'background');
		}

		if (bold) {
			children = chalk.bold(children);
		}

		if (italic) {
			children = chalk.italic(children);
		}

		if (underline) {
			children = chalk.underline(children);
		}

		if (strikethrough) {
			children = chalk.strikethrough(children);
		}

		if (inverse) {
			children = chalk.inverse(children);
		}

		return children;
	};

	if (isScreenReaderEnabled && ariaHidden) {
		return null;
	}

	return (
		<ink-text
			style={{flexGrow: 0, flexShrink: 1, flexDirection: 'row', textWrap: wrap}}
			internal_transform={transform}
		>
			{isScreenReaderEnabled && ariaLabel ? ariaLabel : children}
		</ink-text>
	);
}



================================================
FILE: src/components/Transform.tsx
================================================
import React, {useContext, type ReactNode} from 'react';
import {accessibilityContext} from './AccessibilityContext.js';

export type Props = {
	/**
	Screen-reader-specific text to output. If this is set, all children will be ignored.
	*/
	readonly accessibilityLabel?: string;

	/**
	Function that transforms children output. It accepts children and must return transformed children as well.
	*/
	readonly transform: (children: string, index: number) => string;

	readonly children?: ReactNode;
};

/**
Transform a string representation of React components before they're written to output. For example, you might want to apply a gradient to text, add a clickable link, or create some text effects. These use cases can't accept React nodes as input; they expect a string. That's what the <Transform> component does: it gives you an output string of its child components and lets you transform it in any way.
*/
export default function Transform({
	children,
	transform,
	accessibilityLabel,
}: Props) {
	const {isScreenReaderEnabled} = useContext(accessibilityContext);

	if (children === undefined || children === null) {
		return null;
	}

	return (
		<ink-text
			style={{flexGrow: 0, flexShrink: 1, flexDirection: 'row'}}
			internal_transform={transform}
		>
			{isScreenReaderEnabled && accessibilityLabel
				? accessibilityLabel
				: children}
		</ink-text>
	);
}



================================================
FILE: src/hooks/use-app.ts
================================================
import {useContext} from 'react';
import AppContext from '../components/AppContext.js';

/**
`useApp` is a React hook that exposes a method to manually exit the app (unmount).
*/
const useApp = () => useContext(AppContext);
export default useApp;



================================================
FILE: src/hooks/use-focus-manager.ts
================================================
import {useContext} from 'react';
import FocusContext, {type Props} from '../components/FocusContext.js';

type Output = {
	/**
	Enable focus management for all components.
	*/
	enableFocus: Props['enableFocus'];

	/**
	Disable focus management for all components. The currently active component (if there's one) will lose its focus.
	*/
	disableFocus: Props['disableFocus'];

	/**
	Switch focus to the next focusable component. If there's no active component right now, focus will be given to the first focusable component. If the active component is the last in the list of focusable components, focus will be switched to the first focusable component.
	*/
	focusNext: Props['focusNext'];

	/**
	Switch focus to the previous focusable component. If there's no active component right now, focus will be given to the first focusable component. If the active component is the first in the list of focusable components, focus will be switched to the last focusable component.
	*/
	focusPrevious: Props['focusPrevious'];

	/**
	Switch focus to the element with provided `id`. If there's no element with that `id`, focus will be given to the first focusable component.
	*/
	focus: Props['focus'];
};

/**
This hook exposes methods to enable or disable focus management for all components or manually switch focus to next or previous components.
*/
const useFocusManager = (): Output => {
	const focusContext = useContext(FocusContext);

	return {
		enableFocus: focusContext.enableFocus,
		disableFocus: focusContext.disableFocus,
		focusNext: focusContext.focusNext,
		focusPrevious: focusContext.focusPrevious,
		focus: focusContext.focus,
	};
};

export default useFocusManager;



================================================
FILE: src/hooks/use-focus.ts
================================================
import {useEffect, useContext, useMemo} from 'react';
import FocusContext from '../components/FocusContext.js';
import useStdin from './use-stdin.js';

type Input = {
	/**
	Enable or disable this component's focus, while still maintaining its position in the list of focusable components.
	*/
	isActive?: boolean;

	/**
	Auto-focus this component if there's no active (focused) component right now.
	*/
	autoFocus?: boolean;

	/**
	Assign an ID to this component, so it can be programmatically focused with `focus(id)`.
	*/
	id?: string;
};

type Output = {
	/**
	Determines whether this component is focused.
	*/
	isFocused: boolean;

	/**
	Allows focusing a specific element with the provided `id`.
	*/
	focus: (id: string) => void;
};

/**
A component that uses the `useFocus` hook becomes "focusable" to Ink, so when the user presses <kbd>Tab</kbd>, Ink will switch focus to this component. If there are multiple components that execute the `useFocus` hook, focus will be given to them in the order in which these components are rendered. This hook returns an object with an `isFocused` boolean property, which determines whether this component is focused.
*/
const useFocus = ({
	isActive = true,
	autoFocus = false,
	id: customId,
}: Input = {}): Output => {
	const {isRawModeSupported, setRawMode} = useStdin();
	const {activeId, add, remove, activate, deactivate, focus} =
		useContext(FocusContext);

	const id = useMemo(() => {
		return customId ?? Math.random().toString().slice(2, 7);
	}, [customId]);

	useEffect(() => {
		add(id, {autoFocus});

		return () => {
			remove(id);
		};
	}, [id, autoFocus]);

	useEffect(() => {
		if (isActive) {
			activate(id);
		} else {
			deactivate(id);
		}
	}, [isActive, id]);

	useEffect(() => {
		if (!isRawModeSupported || !isActive) {
			return;
		}

		setRawMode(true);

		return () => {
			setRawMode(false);
		};
	}, [isActive]);

	return {
		isFocused: Boolean(id) && activeId === id,
		focus,
	};
};

export default useFocus;



================================================
FILE: src/hooks/use-input.ts
================================================
import {useEffect} from 'react';
import parseKeypress, {nonAlphanumericKeys} from '../parse-keypress.js';
import reconciler from '../reconciler.js';
import useStdin from './use-stdin.js';

/**
Handy information about a key that was pressed.
*/
export type Key = {
	/**
	Up arrow key was pressed.
	*/
	upArrow: boolean;

	/**
	Down arrow key was pressed.
	*/
	downArrow: boolean;

	/**
	Left arrow key was pressed.
	*/
	leftArrow: boolean;

	/**
	Right arrow key was pressed.
	*/
	rightArrow: boolean;

	/**
	Page Down key was pressed.
	*/
	pageDown: boolean;

	/**
	Page Up key was pressed.
	*/
	pageUp: boolean;

	/**
	Return (Enter) key was pressed.
	*/
	return: boolean;

	/**
	Escape key was pressed.
	*/
	escape: boolean;

	/**
	Ctrl key was pressed.
	*/
	ctrl: boolean;

	/**
	Shift key was pressed.
	*/
	shift: boolean;

	/**
	Tab key was pressed.
	*/
	tab: boolean;

	/**
	Backspace key was pressed.
	*/
	backspace: boolean;

	/**
	Delete key was pressed.
	*/
	delete: boolean;

	/**
	[Meta key](https://en.wikipedia.org/wiki/Meta_key) was pressed.
	*/
	meta: boolean;
};

type Handler = (input: string, key: Key) => void;

type Options = {
	/**
	Enable or disable capturing of user input. Useful when there are multiple `useInput` hooks used at once to avoid handling the same input several times.

	@default true
	*/
	isActive?: boolean;
};

/**
This hook is used for handling user input. It's a more convenient alternative to using `StdinContext` and listening for `data` events. The callback you pass to `useInput` is called for each character when the user enters any input. However, if the user pastes text and it's more than one character, the callback will be called only once, and the whole string will be passed as `input`.

```
import {useInput} from 'ink';

const UserInput = () => {
  useInput((input, key) => {
    if (input === 'q') {
      // Exit program
    }

    if (key.leftArrow) {
      // Left arrow key pressed
    }
  });

  return …
};
```
*/
const useInput = (inputHandler: Handler, options: Options = {}) => {
	// eslint-disable-next-line @typescript-eslint/naming-convention
	const {stdin, setRawMode, internal_exitOnCtrlC, internal_eventEmitter} =
		useStdin();

	useEffect(() => {
		if (options.isActive === false) {
			return;
		}

		setRawMode(true);

		return () => {
			setRawMode(false);
		};
	}, [options.isActive, setRawMode]);

	useEffect(() => {
		if (options.isActive === false) {
			return;
		}

		const handleData = (data: string) => {
			const keypress = parseKeypress(data);

			const key = {
				upArrow: keypress.name === 'up',
				downArrow: keypress.name === 'down',
				leftArrow: keypress.name === 'left',
				rightArrow: keypress.name === 'right',
				pageDown: keypress.name === 'pagedown',
				pageUp: keypress.name === 'pageup',
				return: keypress.name === 'return',
				escape: keypress.name === 'escape',
				ctrl: keypress.ctrl,
				shift: keypress.shift,
				tab: keypress.name === 'tab',
				backspace: keypress.name === 'backspace',
				delete: keypress.name === 'delete',
				// `parseKeypress` parses \u001B\u001B[A (meta + up arrow) as meta = false
				// but with option = true, so we need to take this into account here
				// to avoid breaking changes in Ink.
				// TODO(vadimdemedes): consider removing this in the next major version.
				meta: keypress.meta || keypress.name === 'escape' || keypress.option,
			};

			let input = keypress.ctrl ? keypress.name : keypress.sequence;

			if (nonAlphanumericKeys.includes(keypress.name)) {
				input = '';
			}

			// Strip meta if it's still remaining after `parseKeypress`
			// TODO(vadimdemedes): remove this in the next major version.
			if (input.startsWith('\u001B')) {
				input = input.slice(1);
			}

			if (
				input.length === 1 &&
				typeof input[0] === 'string' &&
				/[A-Z]/.test(input[0])
			) {
				key.shift = true;
			}

			// If app is not supposed to exit on Ctrl+C, then let input listener handle it
			if (!(input === 'c' && key.ctrl) || !internal_exitOnCtrlC) {
				// @ts-expect-error TypeScript types for `batchedUpdates` require an argument, but React's codebase doesn't provide it and it works without it as expected.
				reconciler.batchedUpdates(() => {
					inputHandler(input, key);
				});
			}
		};

		internal_eventEmitter?.on('input', handleData);

		return () => {
			internal_eventEmitter?.removeListener('input', handleData);
		};
	}, [options.isActive, stdin, internal_exitOnCtrlC, inputHandler]);
};

export default useInput;



================================================
FILE: src/hooks/use-is-screen-reader-enabled.ts
================================================
import {useContext} from 'react';
import {accessibilityContext} from '../components/AccessibilityContext.js';

/**
Returns whether a screen reader is enabled. This is useful when you want to render different output for screen readers.
*/
const useIsScreenReaderEnabled = (): boolean => {
	const {isScreenReaderEnabled} = useContext(accessibilityContext);
	return isScreenReaderEnabled;
};

export default useIsScreenReaderEnabled;



================================================
FILE: src/hooks/use-stderr.ts
================================================
import {useContext} from 'react';
import StderrContext from '../components/StderrContext.js';

/**
`useStderr` is a React hook that exposes the stderr stream.
*/
const useStderr = () => useContext(StderrContext);
export default useStderr;



================================================
FILE: src/hooks/use-stdin.ts
================================================
import {useContext} from 'react';
import StdinContext from '../components/StdinContext.js';

/**
`useStdin` is a React hook that exposes the stdin stream.
*/
const useStdin = () => useContext(StdinContext);
export default useStdin;



================================================
FILE: src/hooks/use-stdout.ts
================================================
import {useContext} from 'react';
import StdoutContext from '../components/StdoutContext.js';

/**
`useStdout` is a React hook that exposes the stdout stream where Ink renders your app.
*/
const useStdout = () => useContext(StdoutContext);
export default useStdout;



================================================
FILE: test/background.tsx
================================================
import React from 'react';
import test from 'ava';
import chalk from 'chalk';
import {render, Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';
import createStdout from './helpers/create-stdout.js';
import {enableTestColors, disableTestColors} from './helpers/force-colors.js';

// ANSI escape sequences for background colors
// Note: We test against raw ANSI codes rather than chalk predicates because:
// 1. Different color reset patterns:
//    - Chalk: '\u001b[43mHello \u001b[49m\u001b[43mWorld\u001b[49m' (individual resets)
//    - Ink:   '\u001b[43mHello World\u001b[49m' (continuous blocks)
// 2. Background space fills that chalk doesn't generate:
//    - Ink: '\u001b[41mHello     \u001b[49m\n\u001b[41m          \u001b[49m' (fills entire Box area)
// 3. Context-aware color transitions:
//    - Chalk: '\u001b[43mOuter: \u001b[49m\u001b[44mInner: \u001b[49m\u001b[41mExplicit\u001b[49m'
//    - Ink:   '\u001b[43mOuter: \u001b[44mInner: \u001b[41mExplicit\u001b[49m' (no intermediate resets)
const ansi = {
	// Standard colors
	bgRed: '\u001B[41m',
	bgGreen: '\u001B[42m',
	bgYellow: '\u001B[43m',
	bgBlue: '\u001B[44m',
	bgMagenta: '\u001B[45m',
	bgCyan: '\u001B[46m',

	// Hex/RGB colors (24-bit)
	bgHexRed: '\u001B[48;2;255;0;0m', // #FF0000 or rgb(255,0,0)

	// ANSI256 colors
	bgAnsi256Nine: '\u001B[48;5;9m', // Ansi256(9)

	// Reset
	bgReset: '\u001B[49m',
} as const;

// Enable colors for all tests
test.before(() => {
	enableTestColors();
});

test.after(() => {
	disableTestColors();
});

// Text inheritance tests (these work in non-TTY)
test('Text inherits parent Box background color', t => {
	const output = renderToString(
		<Box backgroundColor="green" alignSelf="flex-start">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, chalk.bgGreen('Hello World'));
});

test('Text explicit background color overrides inherited', t => {
	const output = renderToString(
		<Box backgroundColor="red" alignSelf="flex-start">
			<Text backgroundColor="blue">Hello World</Text>
		</Box>,
	);

	t.is(output, chalk.bgBlue('Hello World'));
});

test('Nested Box background inheritance', t => {
	const output = renderToString(
		<Box backgroundColor="red" alignSelf="flex-start">
			<Box backgroundColor="blue">
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, chalk.bgBlue('Hello World'));
});

test('Text without parent Box background has no inheritance', t => {
	const output = renderToString(
		<Box alignSelf="flex-start">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, 'Hello World');
});

test('Multiple Text elements inherit same background', t => {
	const output = renderToString(
		<Box backgroundColor="yellow" alignSelf="flex-start">
			<Text>Hello </Text>
			<Text>World</Text>
		</Box>,
	);

	// Text nodes are rendered as a single block with shared background
	t.is(output, chalk.bgYellow('Hello World'));
});

test('Mixed text with and without background inheritance', t => {
	const output = renderToString(
		<Box backgroundColor="green" alignSelf="flex-start">
			<Text>Inherited </Text>
			<Text backgroundColor="">No BG </Text>
			<Text backgroundColor="red">Red BG</Text>
		</Box>,
	);

	t.is(output, chalk.bgGreen('Inherited ') + 'No BG ' + chalk.bgRed('Red BG'));
});

test('Complex nested structure with background inheritance', t => {
	const output = renderToString(
		<Box backgroundColor="yellow" alignSelf="flex-start">
			<Box>
				<Text>Outer: </Text>
				<Box backgroundColor="blue">
					<Text>Inner: </Text>
					<Text backgroundColor="red">Explicit</Text>
				</Box>
			</Box>
		</Box>,
	);

	// Colors transition without reset codes between them - actual behavior from debug output
	t.is(
		output,
		`${ansi.bgYellow}Outer: ${ansi.bgBlue}Inner: ${ansi.bgRed}Explicit${ansi.bgReset}`,
	);
});

// Background color tests for different formats
test('Box background with standard color', t => {
	const output = renderToString(
		<Box backgroundColor="red" alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	t.is(output, chalk.bgRed('Hello'));
});

test('Box background with hex color', t => {
	const output = renderToString(
		<Box backgroundColor="#FF0000" alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	t.is(output, chalk.bgHex('#FF0000')('Hello'));
});

test('Box background with rgb color', t => {
	const output = renderToString(
		<Box backgroundColor="rgb(255, 0, 0)" alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	t.is(output, chalk.bgRgb(255, 0, 0)('Hello'));
});

test('Box background with ansi256 color', t => {
	const output = renderToString(
		<Box backgroundColor="ansi256(9)" alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	t.is(output, chalk.bgAnsi256(9)('Hello'));
});

test('Box background with wide characters', t => {
	const output = renderToString(
		<Box backgroundColor="yellow" alignSelf="flex-start">
			<Text>こんにちは</Text>
		</Box>,
	);

	t.is(output, chalk.bgYellow('こんにちは'));
});

test('Box background with emojis', t => {
	const output = renderToString(
		<Box backgroundColor="red" alignSelf="flex-start">
			<Text>🎉🎊</Text>
		</Box>,
	);

	t.is(output, chalk.bgRed('🎉🎊'));
});

// Box background space fill tests - these should work with forced colors
test('Box background fills entire area with standard color', t => {
	const output = renderToString(
		<Box backgroundColor="red" width={10} height={3} alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	// Should contain background color codes and fill spaces for entire Box area
	t.true(
		output.includes(ansi.bgRed),
		'Should contain red background start code',
	);
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
	t.true(output.includes('Hello'), 'Should contain the text');
	t.true(
		output.includes(`${ansi.bgRed}          ${ansi.bgReset}`),
		'Should contain background fill line',
	);
});

test('Box background fills with hex color', t => {
	const output = renderToString(
		<Box backgroundColor="#FF0000" width={10} height={3} alignSelf="flex-start">
			<Text>Hello</Text>
		</Box>,
	);

	// Should contain hex color background codes and fill spaces
	t.true(output.includes('Hello'), 'Should contain the text');
	t.true(
		output.includes(ansi.bgHexRed),
		'Should contain hex RGB background code',
	);
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

test('Box background fills with rgb color', t => {
	const output = renderToString(
		<Box
			backgroundColor="rgb(255, 0, 0)"
			width={10}
			height={3}
			alignSelf="flex-start"
		>
			<Text>Hello</Text>
		</Box>,
	);

	// Should contain RGB color background codes and fill spaces
	t.true(output.includes('Hello'), 'Should contain the text');
	t.true(output.includes(ansi.bgHexRed), 'Should contain RGB background code');
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

test('Box background fills with ansi256 color', t => {
	const output = renderToString(
		<Box
			backgroundColor="ansi256(9)"
			width={10}
			height={3}
			alignSelf="flex-start"
		>
			<Text>Hello</Text>
		</Box>,
	);

	// Should contain ANSI256 color background codes and fill spaces
	t.true(output.includes('Hello'), 'Should contain the text');
	t.true(
		output.includes(ansi.bgAnsi256Nine),
		'Should contain ANSI256 background code',
	);
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

test('Box background with border fills content area', t => {
	const output = renderToString(
		<Box
			backgroundColor="cyan"
			borderStyle="round"
			width={10}
			height={5}
			alignSelf="flex-start"
		>
			<Text>Hi</Text>
		</Box>,
	);

	// Should have background fill inside the border and border characters
	t.true(output.includes('Hi'), 'Should contain the text');
	t.true(output.includes(ansi.bgCyan), 'Should contain cyan background code');
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
	t.true(output.includes('╭'), 'Should contain top-left border');
	t.true(output.includes('╮'), 'Should contain top-right border');
});

test('Box background with padding fills entire padded area', t => {
	const output = renderToString(
		<Box
			backgroundColor="magenta"
			padding={1}
			width={10}
			height={5}
			alignSelf="flex-start"
		>
			<Text>Hi</Text>
		</Box>,
	);

	// Background should fill the entire Box area including padding
	t.true(output.includes('Hi'), 'Should contain the text');
	t.true(
		output.includes(ansi.bgMagenta),
		'Should contain magenta background code',
	);
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

test('Box background with center alignment fills entire area', t => {
	const output = renderToString(
		<Box
			backgroundColor="blue"
			width={10}
			height={3}
			justifyContent="center"
			alignSelf="flex-start"
		>
			<Text>Hi</Text>
		</Box>,
	);

	t.true(output.includes('Hi'), 'Should contain centered text');
	t.true(output.includes(ansi.bgBlue), 'Should contain blue background code');
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

test('Box background with column layout fills entire area', t => {
	const output = renderToString(
		<Box
			backgroundColor="green"
			flexDirection="column"
			width={10}
			height={5}
			alignSelf="flex-start"
		>
			<Text>Line 1</Text>
			<Text>Line 2</Text>
		</Box>,
	);

	t.true(output.includes('Line 1'), 'Should contain first line text');
	t.true(output.includes('Line 2'), 'Should contain second line text');
	t.true(output.includes(ansi.bgGreen), 'Should contain green background code');
	t.true(output.includes(ansi.bgReset), 'Should contain background reset code');
});

// Update tests using render() for comprehensive coverage
test('Box background updates on rerender', t => {
	const stdout = createStdout();

	function Test({bgColor}: {readonly bgColor?: string}) {
		return (
			<Box backgroundColor={bgColor} alignSelf="flex-start">
				<Text>Hello</Text>
			</Box>
		);
	}

	const {rerender} = render(<Test />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], 'Hello');

	rerender(<Test bgColor="green" />);
	t.is((stdout.write as any).lastCall.args[0], chalk.bgGreen('Hello'));

	rerender(<Test />);
	t.is((stdout.write as any).lastCall.args[0], 'Hello');
});



================================================
FILE: test/borders.tsx
================================================
import React from 'react';
import test from 'ava';
import boxen from 'boxen';
import indentString from 'indent-string';
import cliBoxes from 'cli-boxes';
import chalk from 'chalk';
import {render, Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';
import createStdout from './helpers/create-stdout.js';

test('single node - full width box', t => {
	const output = renderToString(
		<Box borderStyle="round">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello World', {width: 100, borderStyle: 'round'}));
});

test('single node - full width box with colorful border', t => {
	const output = renderToString(
		<Box borderStyle="round" borderColor="green">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('Hello World', {
			width: 100,
			borderStyle: 'round',
			borderColor: 'green',
		}),
	);
});

test('single node - fit-content box', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello World', {borderStyle: 'round'}));
});

test('single node - fit-content box with wide characters', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Text>こんにちは</Text>
		</Box>,
	);

	t.is(output, boxen('こんにちは', {borderStyle: 'round'}));
});

test('single node - fit-content box with emojis', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Text>🌊🌊</Text>
		</Box>,
	);

	t.is(output, boxen('🌊🌊', {borderStyle: 'round'}));
});

test('single node - fixed width box', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20}>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello World'.padEnd(18, ' '), {borderStyle: 'round'}));
});

test('single node - fixed width and height box', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20} height={20}>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('Hello World'.padEnd(18, ' ') + '\n'.repeat(17), {
			borderStyle: 'round',
		}),
	);
});

test('single node - box with padding', t => {
	const output = renderToString(
		<Box borderStyle="round" padding={1} alignSelf="flex-start">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('\n Hello World \n', {borderStyle: 'round'}));
});

test('single node - box with horizontal alignment', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20} justifyContent="center">
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('   Hello World    ', {borderStyle: 'round'}));
});

test('single node - box with vertical alignment', t => {
	const output = renderToString(
		<Box
			borderStyle="round"
			height={20}
			alignItems="center"
			alignSelf="flex-start"
		>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('\n'.repeat(8) + 'Hello World' + '\n'.repeat(9), {
			borderStyle: 'round',
		}),
	);
});

test('single node - box with wrapping', t => {
	const output = renderToString(
		<Box borderStyle="round" width={10}>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello   \nWorld', {borderStyle: 'round'}));
});

test('multiple nodes - full width box', t => {
	const output = renderToString(
		<Box borderStyle="round">
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello World', {width: 100, borderStyle: 'round'}));
});

test('multiple nodes - full width box with colorful border', t => {
	const output = renderToString(
		<Box borderStyle="round" borderColor="green">
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('Hello World', {
			width: 100,
			borderStyle: 'round',
			borderColor: 'green',
		}),
	);
});

test('multiple nodes - fit-content box', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello World', {borderStyle: 'round'}));
});

test('multiple nodes - fixed width box', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20}>
			<Text>{'Hello '}World</Text>
		</Box>,
	);
	t.is(output, boxen('Hello World'.padEnd(18, ' '), {borderStyle: 'round'}));
});

test('multiple nodes - fixed width and height box', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20} height={20}>
			<Text>{'Hello '}World</Text>
		</Box>,
	);
	t.is(
		output,
		boxen('Hello World'.padEnd(18, ' ') + '\n'.repeat(17), {
			borderStyle: 'round',
		}),
	);
});

test('multiple nodes - box with padding', t => {
	const output = renderToString(
		<Box borderStyle="round" padding={1} alignSelf="flex-start">
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(output, boxen('\n Hello World \n', {borderStyle: 'round'}));
});

test('multiple nodes - box with horizontal alignment', t => {
	const output = renderToString(
		<Box borderStyle="round" width={20} justifyContent="center">
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(output, boxen('   Hello World    ', {borderStyle: 'round'}));
});

test('multiple nodes - box with vertical alignment', t => {
	const output = renderToString(
		<Box
			borderStyle="round"
			height={20}
			alignItems="center"
			alignSelf="flex-start"
		>
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('\n'.repeat(8) + 'Hello World' + '\n'.repeat(9), {
			borderStyle: 'round',
		}),
	);
});

test('multiple nodes - box with wrapping', t => {
	const output = renderToString(
		<Box borderStyle="round" width={10}>
			<Text>{'Hello '}World</Text>
		</Box>,
	);

	t.is(output, boxen('Hello   \nWorld', {borderStyle: 'round'}));
});

test('multiple nodes - box with wrapping and long first node', t => {
	const output = renderToString(
		<Box borderStyle="round" width={10}>
			<Text>{'Helloooooo'} World</Text>
		</Box>,
	);

	t.is(output, boxen('Helloooo\noo World', {borderStyle: 'round'}));
});

test('multiple nodes - box with wrapping and very long first node', t => {
	const output = renderToString(
		<Box borderStyle="round" width={10}>
			<Text>{'Hellooooooooooooo'} World</Text>
		</Box>,
	);

	t.is(output, boxen('Helloooo\noooooooo\no World', {borderStyle: 'round'}));
});

test('nested boxes', t => {
	const output = renderToString(
		<Box borderStyle="round" width={40} padding={1}>
			<Box borderStyle="round" justifyContent="center" padding={1}>
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	const nestedBox = indentString(
		boxen('\n Hello World \n', {borderStyle: 'round'}),
		1,
	);

	t.is(
		output,
		boxen(`${' '.repeat(38)}\n${nestedBox}\n`, {borderStyle: 'round'}),
	);
});

test('nested boxes - fit-content box with wide characters on flex-direction row', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Box borderStyle="round">
				<Text>ミスター</Text>
			</Box>
			<Box borderStyle="round">
				<Text>スポック</Text>
			</Box>
			<Box borderStyle="round">
				<Text>カーク船長</Text>
			</Box>
		</Box>,
	);

	const box1 = boxen('ミスター', {borderStyle: 'round'});
	const box2 = boxen('スポック', {borderStyle: 'round'});
	const box3 = boxen('カーク船長', {borderStyle: 'round'});

	const expected = boxen(
		box1
			.split('\n')
			.map(
				(line, index) =>
					line + box2.split('\n')[index]! + box3.split('\n')[index]!,
			)
			.join('\n'),
		{borderStyle: 'round'},
	);

	t.is(output, expected);
});

test('nested boxes - fit-content box with emojis on flex-direction row', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start">
			<Box borderStyle="round">
				<Text>🦾</Text>
			</Box>
			<Box borderStyle="round">
				<Text>🌏</Text>
			</Box>
			<Box borderStyle="round">
				<Text>😋</Text>
			</Box>
		</Box>,
	);

	const box1 = boxen('🦾', {borderStyle: 'round'});
	const box2 = boxen('🌏', {borderStyle: 'round'});
	const box3 = boxen('😋', {borderStyle: 'round'});

	const expected = boxen(
		box1
			.split('\n')
			.map(
				(line, index) =>
					line + box2.split('\n')[index]! + box3.split('\n')[index]!,
			)
			.join('\n'),
		{borderStyle: 'round'},
	);

	t.is(output, expected);
});

test('nested boxes - fit-content box with wide characters on flex-direction column', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start" flexDirection="column">
			<Box borderStyle="round">
				<Text>ミスター</Text>
			</Box>
			<Box borderStyle="round">
				<Text>スポック</Text>
			</Box>
			<Box borderStyle="round">
				<Text>カーク船長</Text>
			</Box>
		</Box>,
	);

	const expected = boxen(
		boxen('ミスター  ', {borderStyle: 'round'}) +
			'\n' +
			boxen('スポック  ', {borderStyle: 'round'}) +
			'\n' +
			boxen('カーク船長', {borderStyle: 'round'}),
		{borderStyle: 'round'},
	);

	t.is(output, expected);
});

test('nested boxes - fit-content box with emojis on flex-direction column', t => {
	const output = renderToString(
		<Box borderStyle="round" alignSelf="flex-start" flexDirection="column">
			<Box borderStyle="round">
				<Text>🦾</Text>
			</Box>
			<Box borderStyle="round">
				<Text>🌏</Text>
			</Box>
			<Box borderStyle="round">
				<Text>😋</Text>
			</Box>
		</Box>,
	);

	const expected = boxen(
		boxen('🦾', {borderStyle: 'round'}) +
			'\n' +
			boxen('🌏', {borderStyle: 'round'}) +
			'\n' +
			boxen('😋', {borderStyle: 'round'}),
		{borderStyle: 'round'},
	);

	t.is(output, expected);
});

test('render border after update', t => {
	const stdout = createStdout();

	function Test({borderColor}: {readonly borderColor?: string}) {
		return (
			<Box borderStyle="round" borderColor={borderColor}>
				<Text>Hello World</Text>
			</Box>
		);
	}

	const {rerender} = render(<Test />, {
		stdout,
		debug: true,
	});

	t.is(
		(stdout.write as any).lastCall.args[0],
		boxen('Hello World', {width: 100, borderStyle: 'round'}),
	);

	rerender(<Test borderColor="green" />);

	t.is(
		(stdout.write as any).lastCall.args[0],
		boxen('Hello World', {
			width: 100,
			borderStyle: 'round',
			borderColor: 'green',
		}),
	);

	rerender(<Test />);

	t.is(
		(stdout.write as any).lastCall.args[0],
		boxen('Hello World', {
			width: 100,
			borderStyle: 'round',
		}),
	);
});

test('hide top border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderTop={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('hide bottom border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderBottom={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			'Below',
		].join('\n'),
	);
});

test('hide top and bottom borders', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderTop={false} borderBottom={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			'Below',
		].join('\n'),
	);
});

test('hide left border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderLeft={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.top.repeat(7)}${cliBoxes.round.topRight}`,
			`Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottom.repeat(7)}${cliBoxes.round.bottomRight}`,
			'Below',
		].join('\n'),
	);
});

test('hide right border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderRight={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}`,
			`${cliBoxes.round.left}Content`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}`,
			'Below',
		].join('\n'),
	);
});

test('hide left and right border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderLeft={false} borderRight={false}>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			cliBoxes.round.top.repeat(7),
			'Content',
			cliBoxes.round.bottom.repeat(7),
			'Below',
		].join('\n'),
	);
});

test('hide all borders', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box
				borderStyle="round"
				borderTop={false}
				borderBottom={false}
				borderLeft={false}
				borderRight={false}
			>
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(output, ['Above', 'Content', 'Below'].join('\n'));
});

test('change color of top border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderTopColor="green">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			chalk.green(
				`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
					cliBoxes.round.topRight
				}`,
			),
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('change color of bottom border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderBottomColor="green">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			chalk.green(
				`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
					cliBoxes.round.bottomRight
				}`,
			),
			'Below',
		].join('\n'),
	);
});

test('change color of left border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderLeftColor="green">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${chalk.green(cliBoxes.round.left)}Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('change color of right border', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderStyle="round" borderRightColor="green">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${cliBoxes.round.left}Content${chalk.green(cliBoxes.round.right)}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('custom border style', t => {
	const output = renderToString(
		<Box
			borderStyle={{
				topLeft: '↘',
				top: '↓',
				topRight: '↙',
				left: '→',
				bottomLeft: '↗',
				bottom: '↑',
				bottomRight: '↖',
				right: '←',
			}}
		>
			<Text>Content</Text>
		</Box>,
	);

	t.is(output, boxen('Content', {width: 100, borderStyle: 'arrow'}));
});

test('dim border color', t => {
	const output = renderToString(
		<Box borderDimColor borderStyle="round">
			<Text>Content</Text>
		</Box>,
	);

	t.is(
		output,
		boxen('Content', {
			width: 100,
			borderStyle: 'round',
			dimBorder: true,
		}),
	);
});

test('dim top border color', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderTopDimColor borderStyle="round">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			chalk.dim(
				`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
					cliBoxes.round.topRight
				}`,
			),
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('dim bottom border color', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderBottomDimColor borderStyle="round">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${cliBoxes.round.left}Content${cliBoxes.round.right}`,
			chalk.dim(
				`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
					cliBoxes.round.bottomRight
				}`,
			),
			'Below',
		].join('\n'),
	);
});

test('dim left border color', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderLeftDimColor borderStyle="round">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${chalk.dim(cliBoxes.round.left)}Content${cliBoxes.round.right}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});

test('dim right border color', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-start">
			<Text>Above</Text>
			<Box borderRightDimColor borderStyle="round">
				<Text>Content</Text>
			</Box>
			<Text>Below</Text>
		</Box>,
	);

	t.is(
		output,
		[
			'Above',
			`${cliBoxes.round.topLeft}${cliBoxes.round.top.repeat(7)}${
				cliBoxes.round.topRight
			}`,
			`${cliBoxes.round.left}Content${chalk.dim(cliBoxes.round.right)}`,
			`${cliBoxes.round.bottomLeft}${cliBoxes.round.bottom.repeat(7)}${
				cliBoxes.round.bottomRight
			}`,
			'Below',
		].join('\n'),
	);
});



================================================
FILE: test/components.tsx
================================================
import EventEmitter from 'node:events';
import test from 'ava';
import chalk from 'chalk';
import React, {Component, useState} from 'react';
import {spy} from 'sinon';
import ansiEscapes from 'ansi-escapes';
import {
	Box,
	Newline,
	render,
	Spacer,
	Static,
	Text,
	Transform,
	useStdin,
} from '../src/index.js';
import createStdout from './helpers/create-stdout.js';
import {renderToString} from './helpers/render-to-string.js';
import {run} from './helpers/run.js';

test('text', t => {
	const output = renderToString(<Text>Hello World</Text>);

	t.is(output, 'Hello World');
});

test('text with variable', t => {
	const output = renderToString(<Text>Count: {1}</Text>);

	t.is(output, 'Count: 1');
});

test('multiple text nodes', t => {
	const output = renderToString(
		<Text>
			{'Hello'}
			{' World'}
		</Text>,
	);

	t.is(output, 'Hello World');
});

test('text with component', t => {
	function World() {
		return <Text>World</Text>;
	}

	const output = renderToString(
		<Text>
			Hello <World />
		</Text>,
	);

	t.is(output, 'Hello World');
});

test('text with fragment', t => {
	const output = renderToString(
		<Text>
			Hello <>World</> {/* eslint-disable-line react/jsx-no-useless-fragment */}
		</Text>,
	);

	t.is(output, 'Hello World');
});

test('wrap text', t => {
	const output = renderToString(
		<Box width={7}>
			<Text wrap="wrap">Hello World</Text>
		</Box>,
	);

	t.is(output, 'Hello\nWorld');
});

test('don’t wrap text if there is enough space', t => {
	const output = renderToString(
		<Box width={20}>
			<Text wrap="wrap">Hello World</Text>
		</Box>,
	);

	t.is(output, 'Hello World');
});

test('truncate text in the end', t => {
	const output = renderToString(
		<Box width={7}>
			<Text wrap="truncate">Hello World</Text>
		</Box>,
	);

	t.is(output, 'Hello …');
});

test('truncate text in the middle', t => {
	const output = renderToString(
		<Box width={7}>
			<Text wrap="truncate-middle">Hello World</Text>
		</Box>,
	);

	t.is(output, 'Hel…rld');
});

test('truncate text in the beginning', t => {
	const output = renderToString(
		<Box width={7}>
			<Text wrap="truncate-start">Hello World</Text>
		</Box>,
	);

	t.is(output, '… World');
});

test('ignore empty text node', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Box>
				<Text>Hello World</Text>
			</Box>
			<Text>{''}</Text>
		</Box>,
	);

	t.is(output, 'Hello World');
});

test('render a single empty text node', t => {
	const output = renderToString(<Text>{''}</Text>);
	t.is(output, '');
});

test('number', t => {
	const output = renderToString(<Text>{1}</Text>);

	t.is(output, '1');
});

test('fail when text nodes are not within <Text> component', t => {
	let error: Error | undefined;

	class ErrorBoundary extends Component<{children?: React.ReactNode}> {
		override render() {
			return this.props.children;
		}

		override componentDidCatch(reactError: Error) {
			error = reactError;
		}
	}

	renderToString(
		<ErrorBoundary>
			<Box>
				Hello
				<Text>World</Text>
			</Box>
		</ErrorBoundary>,
	);

	t.truthy(error);
	t.is(
		error?.message,
		'Text string "Hello" must be rendered inside <Text> component',
	);
});

test('fail when text node is not within <Text> component', t => {
	let error: Error | undefined;

	class ErrorBoundary extends Component<{children?: React.ReactNode}> {
		override render() {
			return this.props.children;
		}

		override componentDidCatch(reactError: Error) {
			error = reactError;
		}
	}

	renderToString(
		<ErrorBoundary>
			<Box>Hello World</Box>
		</ErrorBoundary>,
	);

	t.truthy(error);
	t.is(
		error?.message,
		'Text string "Hello World" must be rendered inside <Text> component',
	);
});

test('fail when <Box> is inside <Text> component', t => {
	let error: Error | undefined;

	class ErrorBoundary extends Component<{children?: React.ReactNode}> {
		override render() {
			return this.props.children;
		}

		override componentDidCatch(reactError: Error) {
			error = reactError;
		}
	}

	renderToString(
		<ErrorBoundary>
			<Text>
				Hello World
				<Box />
			</Text>
		</ErrorBoundary>,
	);

	t.truthy(error);
	t.is((error as any).message, '<Box> can’t be nested inside <Text> component');
});

test('remesure text dimensions on text change', t => {
	const stdout = createStdout();

	const {rerender} = render(
		<Box>
			<Text>Hello</Text>
		</Box>,
		{stdout, debug: true},
	);

	t.is((stdout.write as any).lastCall.args[0], 'Hello');

	rerender(
		<Box>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is((stdout.write as any).lastCall.args[0], 'Hello World');
});

test('fragment', t => {
	const output = renderToString(
		// eslint-disable-next-line react/jsx-no-useless-fragment
		<>
			<Text>Hello World</Text>
		</>,
	);

	t.is(output, 'Hello World');
});

test('transform children', t => {
	const output = renderToString(
		<Transform
			transform={(string: string, index: number) => `[${index}: ${string}]`}
		>
			<Text>
				<Transform
					transform={(string: string, index: number) => `{${index}: ${string}}`}
				>
					<Text>test</Text>
				</Transform>
			</Text>
		</Transform>,
	);

	t.is(output, '[0: {0: test}]');
});

test('squash multiple text nodes', t => {
	const output = renderToString(
		<Transform
			transform={(string: string, index: number) => `[${index}: ${string}]`}
		>
			<Text>
				<Transform
					transform={(string: string, index: number) => `{${index}: ${string}}`}
				>
					{/* prettier-ignore */}
					<Text>hello{' '}world</Text>
				</Transform>
			</Text>
		</Transform>,
	);

	t.is(output, '[0: {0: hello world}]');
});

test('transform with multiple lines', t => {
	const output = renderToString(
		<Transform
			transform={(string: string, index: number) => `[${index}: ${string}]`}
		>
			{/* prettier-ignore */}
			<Text>hello{' '}world{'\n'}goodbye{' '}world</Text>
		</Transform>,
	);

	t.is(output, '[0: hello world]\n[1: goodbye world]');
});

test('squash multiple nested text nodes', t => {
	const output = renderToString(
		<Transform
			transform={(string: string, index: number) => `[${index}: ${string}]`}
		>
			<Text>
				<Transform
					transform={(string: string, index: number) => `{${index}: ${string}}`}
				>
					hello
					<Text> world</Text>
				</Transform>
			</Text>
		</Transform>,
	);

	t.is(output, '[0: {0: hello world}]');
});

test('squash empty `<Text>` nodes', t => {
	const output = renderToString(
		<Transform transform={(string: string) => `[${string}]`}>
			<Text>
				<Transform transform={(string: string) => `{${string}}`}>
					<Text>{[]}</Text>
				</Transform>
			</Text>
		</Transform>,
	);

	t.is(output, '');
});

test('<Transform> with undefined children', t => {
	const output = renderToString(<Transform transform={children => children} />);
	t.is(output, '');
});

test('<Transform> with null children', t => {
	const output = renderToString(<Transform transform={children => children} />);
	t.is(output, '');
});

test('hooks', t => {
	function WithHooks() {
		const [value, setValue] = useState('Hello');

		return <Text>{value}</Text>;
	}

	const output = renderToString(<WithHooks />);
	t.is(output, 'Hello');
});

test('static output', t => {
	const output = renderToString(
		<Box>
			<Static items={['A', 'B', 'C']} style={{paddingBottom: 1}}>
				{letter => <Text key={letter}>{letter}</Text>}
			</Static>

			<Box marginTop={1}>
				<Text>X</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'A\nB\nC\n\n\nX');
});

test('skip previous output when rendering new static output', t => {
	const stdout = createStdout();

	function Dynamic({items}: {readonly items: string[]}) {
		return (
			<Static items={items}>{item => <Text key={item}>{item}</Text>}</Static>
		);
	}

	const {rerender} = render(<Dynamic items={['A']} />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], 'A\n');

	rerender(<Dynamic items={['A', 'B']} />);
	t.is((stdout.write as any).lastCall.args[0], 'A\nB\n');
});

test('render only new items in static output on final render', t => {
	const stdout = createStdout();

	function Dynamic({items}: {readonly items: string[]}) {
		return (
			<Static items={items}>{item => <Text key={item}>{item}</Text>}</Static>
		);
	}

	const {rerender, unmount} = render(<Dynamic items={[]} />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], '');

	rerender(<Dynamic items={['A']} />);
	t.is((stdout.write as any).lastCall.args[0], 'A\n');

	rerender(<Dynamic items={['A', 'B']} />);
	unmount();
	t.is((stdout.write as any).lastCall.args[0], 'A\nB\n');
});

// See https://github.com/chalk/wrap-ansi/issues/27
test('ensure wrap-ansi doesn’t trim leading whitespace', t => {
	const output = renderToString(<Text color="red">{' ERROR '}</Text>);

	t.is(output, chalk.red(' ERROR '));
});

test('replace child node with text', t => {
	const stdout = createStdout();

	function Dynamic({replace}: {readonly replace?: boolean}) {
		return <Text>{replace ? 'x' : <Text color="green">test</Text>}</Text>;
	}

	const {rerender} = render(<Dynamic />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], chalk.green('test'));

	rerender(<Dynamic replace />);
	t.is((stdout.write as any).lastCall.args[0], 'x');
});

// See https://github.com/vadimdemedes/ink/issues/145
test('disable raw mode when all input components are unmounted', t => {
	const stdout = createStdout();

	const stdin = new EventEmitter() as NodeJS.WriteStream;
	stdin.setEncoding = () => {};
	stdin.setRawMode = spy();
	stdin.isTTY = true; // Without this, setRawMode will throw
	stdin.ref = spy();
	stdin.unref = spy();

	const options = {
		stdout,
		stdin,
		debug: true,
	};

	class Input extends React.Component<{setRawMode: (mode: boolean) => void}> {
		override render() {
			return <Text>Test</Text>;
		}

		override componentDidMount() {
			this.props.setRawMode(true);
		}

		override componentWillUnmount() {
			this.props.setRawMode(false);
		}
	}

	function Test({
		renderFirstInput,
		renderSecondInput,
	}: {
		readonly renderFirstInput?: boolean;
		readonly renderSecondInput?: boolean;
	}) {
		const {setRawMode} = useStdin();

		return (
			<>
				{renderFirstInput && <Input setRawMode={setRawMode} />}
				{renderSecondInput && <Input setRawMode={setRawMode} />}
			</>
		);
	}

	const {rerender} = render(
		<Test renderFirstInput renderSecondInput />,
		// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		options as any,
	);

	t.true(stdin.setRawMode.calledOnce);
	t.true(stdin.ref.calledOnce);
	t.deepEqual(stdin.setRawMode.firstCall.args, [true]);

	rerender(<Test renderFirstInput />);

	t.true(stdin.setRawMode.calledOnce);
	t.true(stdin.ref.calledOnce);
	t.true(stdin.unref.notCalled);

	rerender(<Test />);

	t.true(stdin.setRawMode.calledTwice);
	t.true(stdin.ref.calledOnce);
	t.true(stdin.unref.calledOnce);
	t.deepEqual(stdin.setRawMode.lastCall.args, [false]);
});

test('setRawMode() should throw if raw mode is not supported', t => {
	const stdout = createStdout();

	const stdin = new EventEmitter() as NodeJS.ReadStream;
	stdin.setEncoding = () => {};
	stdin.setRawMode = spy();
	stdin.isTTY = false;

	const didCatchInMount = spy();
	const didCatchInUnmount = spy();

	const options = {
		stdout,
		stdin,
		debug: true,
	};

	class Input extends React.Component<{setRawMode: (mode: boolean) => void}> {
		override render() {
			return <Text>Test</Text>;
		}

		override componentDidMount() {
			try {
				this.props.setRawMode(true);
			} catch (error: unknown) {
				didCatchInMount(error);
			}
		}

		override componentWillUnmount() {
			try {
				this.props.setRawMode(false);
			} catch (error: unknown) {
				didCatchInUnmount(error);
			}
		}
	}

	function Test() {
		const {setRawMode} = useStdin();
		return <Input setRawMode={setRawMode} />;
	}

	const {unmount} = render(<Test />, options);
	unmount();

	t.is(didCatchInMount.callCount, 1);
	t.is(didCatchInUnmount.callCount, 1);
	t.false(stdin.setRawMode.called);
});

test('render different component based on whether stdin is a TTY or not', t => {
	const stdout = createStdout();

	const stdin = new EventEmitter() as NodeJS.WriteStream;
	stdin.setEncoding = () => {};
	stdin.setRawMode = spy();
	stdin.isTTY = false;

	const options = {
		stdout,
		stdin,
		debug: true,
	};

	class Input extends React.Component<{setRawMode: (mode: boolean) => void}> {
		override render() {
			return <Text>Test</Text>;
		}

		override componentDidMount() {
			this.props.setRawMode(true);
		}

		override componentWillUnmount() {
			this.props.setRawMode(false);
		}
	}

	function Test({
		renderFirstInput,
		renderSecondInput,
	}: {
		readonly renderFirstInput?: boolean;
		readonly renderSecondInput?: boolean;
	}) {
		const {isRawModeSupported, setRawMode} = useStdin();

		return (
			<>
				{isRawModeSupported && renderFirstInput && (
					<Input setRawMode={setRawMode} />
				)}
				{isRawModeSupported && renderSecondInput && (
					<Input setRawMode={setRawMode} />
				)}
			</>
		);
	}

	const {rerender} = render(
		<Test renderFirstInput renderSecondInput />,
		// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		options as any,
	);

	t.false(stdin.setRawMode.called);

	rerender(<Test renderFirstInput />);

	t.false(stdin.setRawMode.called);

	rerender(<Test />);

	t.false(stdin.setRawMode.called);
});

test('render only last frame when run in CI', async t => {
	const output = await run('ci', {
		// eslint-disable-next-line @typescript-eslint/naming-convention
		env: {CI: 'true'},
		columns: 0,
	});

	for (const num of [0, 1, 2, 3, 4]) {
		t.false(output.includes(`Counter: ${num}`));
	}

	t.true(output.includes('Counter: 5'));
});

test('render all frames if CI environment variable equals false', async t => {
	const output = await run('ci', {
		// eslint-disable-next-line @typescript-eslint/naming-convention
		env: {CI: 'false'},
		columns: 0,
	});

	for (const num of [0, 1, 2, 3, 4, 5]) {
		t.true(output.includes(`Counter: ${num}`));
	}
});

test('reset prop when it’s removed from the element', t => {
	const stdout = createStdout();

	function Dynamic({remove}: {readonly remove?: boolean}) {
		return (
			<Box
				flexDirection="column"
				justifyContent="flex-end"
				height={remove ? undefined : 4}
			>
				<Text>x</Text>
			</Box>
		);
	}

	const {rerender} = render(<Dynamic />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], '\n\n\nx');

	rerender(<Dynamic remove />);
	t.is((stdout.write as any).lastCall.args[0], 'x');
});

test('newline', t => {
	const output = renderToString(
		<Text>
			Hello
			<Newline />
			World
		</Text>,
	);
	t.is(output, 'Hello\nWorld');
});

test('multiple newlines', t => {
	const output = renderToString(
		<Text>
			Hello
			<Newline count={2} />
			World
		</Text>,
	);
	t.is(output, 'Hello\n\nWorld');
});

test('horizontal spacer', t => {
	const output = renderToString(
		<Box width={20}>
			<Text>Left</Text>
			<Spacer />
			<Text>Right</Text>
		</Box>,
	);

	t.is(output, 'Left           Right');
});

test('vertical spacer', t => {
	const output = renderToString(
		<Box flexDirection="column" height={6}>
			<Text>Top</Text>
			<Spacer />
			<Text>Bottom</Text>
		</Box>,
	);

	t.is(output, 'Top\n\n\n\n\nBottom');
});

test('link ansi escapes are closed properly', t => {
	const output = renderToString(
		<Text>{ansiEscapes.link('Example', 'https://example.com')}</Text>,
	);

	t.is(output, ']8;;https://example.comExample]8;;');
});



================================================
FILE: test/display.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('display flex', t => {
	const output = renderToString(
		<Box display="flex">
			<Text>X</Text>
		</Box>,
	);
	t.is(output, 'X');
});

test('display none', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Box display="none">
				<Text>Kitty!</Text>
			</Box>
			<Text>Doggo</Text>
		</Box>,
	);

	t.is(output, 'Doggo');
});



================================================
FILE: test/errors.tsx
================================================
import React from 'react';
import test from 'ava';
import patchConsole from 'patch-console';
import stripAnsi from 'strip-ansi';
import {render} from '../src/index.js';
import createStdout from './helpers/create-stdout.js';

let restore = () => {};

test.before(() => {
	restore = patchConsole(() => {});
});

test.after(() => {
	restore();
});

test('catch and display error', t => {
	const stdout = createStdout();

	const Test = () => {
		throw new Error('Oh no');
	};

	render(<Test />, {stdout});

	t.deepEqual(
		stripAnsi((stdout.write as any).lastCall.args[0] as string)
			.split('\n')
			.slice(0, 14),
		[
			'',
			'  ERROR  Oh no',
			'',
			' test/errors.tsx:22:9',
			'',
			' 19:   const stdout = createStdout();',
			' 20:',
			' 21:   const Test = () => {',
			" 22:     throw new Error('Oh no');",
			' 23:   };',
			' 24:',
			' 25:   render(<Test />, {stdout});',
			'',
			' - Test (test/errors.tsx:22:9)',
		],
	);
});



================================================
FILE: test/exit.tsx
================================================
import process from 'node:process';
import * as path from 'node:path';
import url from 'node:url';
import {createRequire} from 'node:module';
import test from 'ava';
import {run} from './helpers/run.js';

const require = createRequire(import.meta.url);

// eslint-disable-next-line @typescript-eslint/consistent-type-imports
const {spawn} = require('node-pty') as typeof import('node-pty');

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

test.serial('exit normally without unmount() or exit()', async t => {
	const output = await run('exit-normally');
	t.true(output.includes('exited'));
});

test.serial('exit on unmount()', async t => {
	const output = await run('exit-on-unmount');
	t.true(output.includes('exited'));
});

test.serial('exit when app finishes execution', async t => {
	const ps = run('exit-on-finish');
	await t.notThrowsAsync(ps);
});

test.serial('exit on exit()', async t => {
	const output = await run('exit-on-exit');
	t.true(output.includes('exited'));
});

test.serial('exit on exit() with error', async t => {
	const output = await run('exit-on-exit-with-error');
	t.true(output.includes('errored'));
});

test.serial('exit on exit() with raw mode', async t => {
	const output = await run('exit-raw-on-exit');
	t.true(output.includes('exited'));
});

test.serial('exit on exit() with raw mode with error', async t => {
	const output = await run('exit-raw-on-exit-with-error');
	t.true(output.includes('errored'));
});

test.serial('exit on unmount() with raw mode', async t => {
	const output = await run('exit-raw-on-unmount');
	t.true(output.includes('exited'));
});

test.serial('exit with thrown error', async t => {
	const output = await run('exit-with-thrown-error');
	t.true(output.includes('errored'));
});

test.serial('don’t exit while raw mode is active', async t => {
	await new Promise<void>((resolve, _reject) => {
		const env: Record<string, string> = {
			...process.env,
			// eslint-disable-next-line @typescript-eslint/naming-convention
			NODE_NO_WARNINGS: '1',
		};

		const term = spawn(
			'node',
			[
				'--loader=ts-node/esm',
				path.join(__dirname, './fixtures/exit-double-raw-mode.tsx'),
			],
			{
				name: 'xterm-color',
				cols: 100,
				cwd: __dirname,
				env,
			},
		);

		let output = '';

		term.onData(data => {
			if (data === 's') {
				setTimeout(() => {
					t.false(isExited);
					term.write('q');
				}, 2000);

				setTimeout(() => {
					term.kill();
					t.fail();
					resolve();
				}, 5000);
			} else {
				output += data;
			}
		});

		let isExited = false;

		term.onExit(({exitCode}) => {
			isExited = true;

			if (exitCode === 0) {
				t.true(output.includes('exited'));
				t.pass();
				resolve();
				return;
			}

			t.fail();
			resolve();
		});
	});
});



================================================
FILE: test/flex-align-items.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('row - align text to center', t => {
	const output = renderToString(
		<Box alignItems="center" height={3}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '\nTest\n');
});

test('row - align multiple text nodes to center', t => {
	const output = renderToString(
		<Box alignItems="center" height={3}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '\nAB\n');
});

test('row - align text to bottom', t => {
	const output = renderToString(
		<Box alignItems="flex-end" height={3}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '\n\nTest');
});

test('row - align multiple text nodes to bottom', t => {
	const output = renderToString(
		<Box alignItems="flex-end" height={3}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '\n\nAB');
});

test('column - align text to center', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="center" width={10}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '   Test');
});

test('column - align text to right', t => {
	const output = renderToString(
		<Box flexDirection="column" alignItems="flex-end" width={10}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '      Test');
});



================================================
FILE: test/flex-align-self.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('row - align text to center', t => {
	const output = renderToString(
		<Box height={3}>
			<Box alignSelf="center">
				<Text>Test</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\nTest\n');
});

test('row - align multiple text nodes to center', t => {
	const output = renderToString(
		<Box height={3}>
			<Box alignSelf="center">
				<Text>A</Text>
				<Text>B</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\nAB\n');
});

test('row - align text to bottom', t => {
	const output = renderToString(
		<Box height={3}>
			<Box alignSelf="flex-end">
				<Text>Test</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\nTest');
});

test('row - align multiple text nodes to bottom', t => {
	const output = renderToString(
		<Box height={3}>
			<Box alignSelf="flex-end">
				<Text>A</Text>
				<Text>B</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\nAB');
});

test('column - align text to center', t => {
	const output = renderToString(
		<Box flexDirection="column" width={10}>
			<Box alignSelf="center">
				<Text>Test</Text>
			</Box>
		</Box>,
	);

	t.is(output, '   Test');
});

test('column - align text to right', t => {
	const output = renderToString(
		<Box flexDirection="column" width={10}>
			<Box alignSelf="flex-end">
				<Text>Test</Text>
			</Box>
		</Box>,
	);

	t.is(output, '      Test');
});



================================================
FILE: test/flex-direction.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('direction row', t => {
	const output = renderToString(
		<Box flexDirection="row">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'AB');
});

test('direction row reverse', t => {
	const output = renderToString(
		<Box flexDirection="row-reverse" width={4}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '  BA');
});

test('direction column', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\nB');
});

test('direction column reverse', t => {
	const output = renderToString(
		<Box flexDirection="column-reverse" height={4}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '\n\nB\nA');
});

test('don’t squash text nodes when column direction is applied', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\nB');
});



================================================
FILE: test/flex-justify-content.tsx
================================================
import React from 'react';
import test from 'ava';
import chalk from 'chalk';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('row - align text to center', t => {
	const output = renderToString(
		<Box justifyContent="center" width={10}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '   Test');
});

test('row - align multiple text nodes to center', t => {
	const output = renderToString(
		<Box justifyContent="center" width={10}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '    AB');
});

test('row - align text to right', t => {
	const output = renderToString(
		<Box justifyContent="flex-end" width={10}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '      Test');
});

test('row - align multiple text nodes to right', t => {
	const output = renderToString(
		<Box justifyContent="flex-end" width={10}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '        AB');
});

test('row - align two text nodes on the edges', t => {
	const output = renderToString(
		<Box justifyContent="space-between" width={4}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A  B');
});

test('row - space evenly two text nodes', t => {
	const output = renderToString(
		<Box justifyContent="space-evenly" width={10}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, '  A   B');
});

// Yoga has a bug, where first child in a container with space-around doesn't have
// the correct X coordinate and measure function is used on that child node
test.failing('row - align two text nodes with equal space around them', t => {
	const output = renderToString(
		<Box justifyContent="space-around" width={5}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, ' A B');
});

test('row - align colored text node when text is squashed', t => {
	const output = renderToString(
		<Box justifyContent="flex-end" width={5}>
			<Text color="green">X</Text>
		</Box>,
	);

	t.is(output, `    ${chalk.green('X')}`);
});

test('column - align text to center', t => {
	const output = renderToString(
		<Box flexDirection="column" justifyContent="center" height={3}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '\nTest\n');
});

test('column - align text to bottom', t => {
	const output = renderToString(
		<Box flexDirection="column" justifyContent="flex-end" height={3}>
			<Text>Test</Text>
		</Box>,
	);

	t.is(output, '\n\nTest');
});

test('column - align two text nodes on the edges', t => {
	const output = renderToString(
		<Box flexDirection="column" justifyContent="space-between" height={4}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\n\n\nB');
});

// Yoga has a bug, where first child in a container with space-around doesn't have
// the correct X coordinate and measure function is used on that child node
test.failing(
	'column - align two text nodes with equal space around them',
	t => {
		const output = renderToString(
			<Box flexDirection="column" justifyContent="space-around" height={5}>
				<Text>A</Text>
				<Text>B</Text>
			</Box>,
		);

		t.is(output, '\nA\n\nB\n');
	},
);



================================================
FILE: test/flex-wrap.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('row - no wrap', t => {
	const output = renderToString(
		<Box width={2}>
			<Text>A</Text>
			<Text>BC</Text>
		</Box>,
	);

	t.is(output, 'BC\n');
});

test('column - no wrap', t => {
	const output = renderToString(
		<Box flexDirection="column" height={2}>
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, 'B\nC');
});

test('row - wrap content', t => {
	const output = renderToString(
		<Box width={2} flexWrap="wrap">
			<Text>A</Text>
			<Text>BC</Text>
		</Box>,
	);

	t.is(output, 'A\nBC');
});

test('column - wrap content', t => {
	const output = renderToString(
		<Box flexDirection="column" height={2} flexWrap="wrap">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, 'AC\nB');
});

test('column - wrap content reverse', t => {
	const output = renderToString(
		<Box flexDirection="column" height={2} width={3} flexWrap="wrap-reverse">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, ' CA\n  B');
});

test('row - wrap content reverse', t => {
	const output = renderToString(
		<Box height={3} width={2} flexWrap="wrap-reverse">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, '\nC\nAB');
});



================================================
FILE: test/flex.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('grow equally', t => {
	const output = renderToString(
		<Box width={6}>
			<Box flexGrow={1}>
				<Text>A</Text>
			</Box>
			<Box flexGrow={1}>
				<Text>B</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'A  B');
});

test('grow one element', t => {
	const output = renderToString(
		<Box width={6}>
			<Box flexGrow={1}>
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A    B');
});

test('dont shrink', t => {
	const output = renderToString(
		<Box width={16}>
			<Box flexShrink={0} width={6}>
				<Text>A</Text>
			</Box>
			<Box flexShrink={0} width={6}>
				<Text>B</Text>
			</Box>
			<Box width={6}>
				<Text>C</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'A     B     C');
});

test('shrink equally', t => {
	const output = renderToString(
		<Box width={10}>
			<Box flexShrink={1} width={6}>
				<Text>A</Text>
			</Box>
			<Box flexShrink={1} width={6}>
				<Text>B</Text>
			</Box>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, 'A    B   C');
});

test('set flex basis with flexDirection="row" container', t => {
	const output = renderToString(
		<Box width={6}>
			<Box flexBasis={3}>
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A  B');
});

test('set flex basis in percent with flexDirection="row" container', t => {
	const output = renderToString(
		<Box width={6}>
			<Box flexBasis="50%">
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A  B');
});

test('set flex basis with flexDirection="column" container', t => {
	const output = renderToString(
		<Box height={6} flexDirection="column">
			<Box flexBasis={3}>
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\n\n\nB\n\n');
});

test('set flex basis in percent with flexDirection="column" container', t => {
	const output = renderToString(
		<Box height={6} flexDirection="column">
			<Box flexBasis="50%">
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\n\n\nB\n\n');
});



================================================
FILE: test/focus.tsx
================================================
import EventEmitter from 'node:events';
import React, {useEffect} from 'react';
import delay from 'delay';
import test from 'ava';
import {spy, stub} from 'sinon';
import {render, Box, Text, useFocus, useFocusManager} from '../src/index.js';
import createStdout from './helpers/create-stdout.js';

const createStdin = () => {
	const stdin = new EventEmitter() as unknown as NodeJS.WriteStream;
	stdin.isTTY = true;
	stdin.setRawMode = spy();
	stdin.setEncoding = () => {};
	stdin.read = stub();
	stdin.unref = () => {};
	stdin.ref = () => {};

	return stdin;
};

const emitReadable = (stdin: NodeJS.WriteStream, chunk: string) => {
	/* eslint-disable @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment */
	const read = stdin.read as ReturnType<typeof stub>;
	read.onCall(0).returns(chunk);
	read.onCall(1).returns(null);
	stdin.emit('readable');
	read.reset();
	/* eslint-enable @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment */
};

type TestProps = {
	readonly showFirst?: boolean;
	readonly disableFirst?: boolean;
	readonly disableSecond?: boolean;
	readonly disableThird?: boolean;
	readonly autoFocus?: boolean;
	readonly disabled?: boolean;
	readonly focusNext?: boolean;
	readonly focusPrevious?: boolean;
	readonly unmountChildren?: boolean;
};

function Test({
	showFirst = true,
	disableFirst = false,
	disableSecond = false,
	disableThird = false,
	autoFocus = false,
	disabled = false,
	focusNext = false,
	focusPrevious = false,
	unmountChildren = false,
}: TestProps) {
	const focusManager = useFocusManager();

	useEffect(() => {
		if (disabled) {
			focusManager.disableFocus();
		} else {
			focusManager.enableFocus();
		}
	}, [disabled]);

	useEffect(() => {
		if (focusNext) {
			focusManager.focusNext();
		}
	}, [focusNext]);

	useEffect(() => {
		if (focusPrevious) {
			focusManager.focusPrevious();
		}
	}, [focusPrevious]);

	if (unmountChildren) {
		return null;
	}

	return (
		<Box flexDirection="column">
			{showFirst && (
				<Item label="First" autoFocus={autoFocus} disabled={disableFirst} />
			)}
			<Item label="Second" autoFocus={autoFocus} disabled={disableSecond} />
			<Item label="Third" autoFocus={autoFocus} disabled={disableThird} />
		</Box>
	);
}

type ItemProps = {
	readonly label: string;
	readonly autoFocus: boolean;
	readonly disabled?: boolean;
};

function Item({label, autoFocus, disabled = false}: ItemProps) {
	const {isFocused} = useFocus({
		autoFocus,
		isActive: !disabled,
	});

	return (
		<Text>
			{label} {isFocused && '✔'}
		</Text>
	);
}

test('dont focus on register when auto focus is off', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third'].join('\n'),
	);
});

test('focus the first component to register', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);
});

test('unfocus active component on Esc', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\u001B');
	await delay(100);
	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third'].join('\n'),
	);
});

test('switch focus to first component on Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);
});

test('switch focus to the next component on Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);
});

test('switch focus to the first component if currently focused component is the last one on Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third ✔'].join('\n'),
	);

	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);
});

test('skip disabled component on Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus disableSecond />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third ✔'].join('\n'),
	);
});

test('switch focus to the previous component on Shift+Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);

	emitReadable(stdin, '\u001B[Z');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);
});

test('switch focus to the last component if currently focused component is the first one on Shift+Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\u001B[Z');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third ✔'].join('\n'),
	);
});

test('skip disabled component on Shift+Tab', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus disableSecond />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\u001B[Z');
	emitReadable(stdin, '\u001B[Z');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);
});

test('reset focus when focused component unregisters', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test autoFocus showFirst={false} />);
	await delay(100);

	t.is((stdout.write as any).lastCall.args[0], ['Second', 'Third'].join('\n'));
});

test('focus first component after focused component unregisters', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test autoFocus showFirst={false} />);
	await delay(100);

	t.is((stdout.write as any).lastCall.args[0], ['Second', 'Third'].join('\n'));

	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['Second ✔', 'Third'].join('\n'),
	);
});

test('toggle focus management', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test autoFocus disabled />);
	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First ✔', 'Second', 'Third'].join('\n'),
	);

	rerender(<Test autoFocus />);
	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);
});

test('manually focus next component', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test autoFocus focusNext />);
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);
});

test('manually focus previous component', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test autoFocus focusPrevious />);
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third ✔'].join('\n'),
	);
});

test('doesnt crash when focusing next on unmounted children', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test focusNext unmountChildren />);
	await delay(100);

	t.is((stdout.write as any).lastCall.args[0], '');
});

test('doesnt crash when focusing previous on unmounted children', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	const {rerender} = render(<Test autoFocus />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	rerender(<Test focusPrevious unmountChildren />);
	await delay(100);

	t.is((stdout.write as any).lastCall.args[0], '');
});

test('focuses first non-disabled component', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus disableFirst disableSecond />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second', 'Third ✔'].join('\n'),
	);
});

test('skips disabled elements when wrapping around', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus disableFirst />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);
	emitReadable(stdin, '\t');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);
});

test('skips disabled elements when wrapping around from the front', async t => {
	const stdout = createStdout();
	const stdin = createStdin();
	render(<Test autoFocus disableThird />, {
		stdout,
		stdin,
		debug: true,
	});

	await delay(100);
	emitReadable(stdin, '\u001B[Z');
	await delay(100);

	t.is(
		(stdout.write as any).lastCall.args[0],
		['First', 'Second ✔', 'Third'].join('\n'),
	);
});



================================================
FILE: test/gap.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('gap', t => {
	const output = renderToString(
		<Box gap={1} width={3} flexWrap="wrap">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(output, 'A B\n\nC');
});

test('column gap', t => {
	const output = renderToString(
		<Box gap={1}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A B');
});

test('row gap', t => {
	const output = renderToString(
		<Box flexDirection="column" gap={1}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\n\nB');
});



================================================
FILE: test/hooks.tsx
================================================
import process from 'node:process';
import url from 'node:url';
import path from 'node:path';
import test, {type ExecutionContext} from 'ava';
import stripAnsi from 'strip-ansi';
import {spawn} from 'node-pty';

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

const term = (fixture: string, args: string[] = []) => {
	let resolve: (value?: any) => void;
	let reject: (error?: Error) => void;

	// eslint-disable-next-line promise/param-names
	const exitPromise = new Promise((resolve2, reject2) => {
		resolve = resolve2;
		reject = reject2;
	});

	const env: Record<string, string> = {
		...process.env,
		// eslint-disable-next-line @typescript-eslint/naming-convention
		NODE_NO_WARNINGS: '1',
		// eslint-disable-next-line @typescript-eslint/naming-convention
		CI: 'false',
	};

	const ps = spawn(
		'node',
		[
			'--loader=ts-node/esm',
			path.join(__dirname, `./fixtures/${fixture}.tsx`),
			...args,
		],
		{
			name: 'xterm-color',
			cols: 100,
			cwd: __dirname,
			env,
		},
	);

	const result = {
		write(input: string) {
			// Give TS and Ink time to start up and render UI
			// TODO: Send a signal from the Ink process when it's ready to accept input instead
			setTimeout(() => {
				ps.write(input);
			}, 3000);
		},
		output: '',
		waitForExit: async () => exitPromise,
	};

	ps.onData(data => {
		result.output += data;
	});

	ps.onExit(({exitCode}) => {
		if (exitCode === 0) {
			resolve();
			return;
		}

		reject(new Error(`Process exited with non-zero exit code: ${exitCode}`));
	});

	return result;
};

test.serial('useInput - handle lowercase character', async t => {
	const ps = term('use-input', ['lowercase']);
	ps.write('q');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle uppercase character', async t => {
	const ps = term('use-input', ['uppercase']);
	ps.write('Q');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial(
	'useInput - \r should not count as an uppercase character',
	async t => {
		const ps = term('use-input', ['uppercase']);
		ps.write('\r');
		await ps.waitForExit();
		t.true(ps.output.includes('exited'));
	},
);

test.serial('useInput - pasted carriage return', async t => {
	const ps = term('use-input', ['pastedCarriageReturn']);
	ps.write('\rtest');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - pasted tab', async t => {
	const ps = term('use-input', ['pastedTab']);
	ps.write('\ttest');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle escape', async t => {
	const ps = term('use-input', ['escape']);
	ps.write('\u001B');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle ctrl', async t => {
	const ps = term('use-input', ['ctrl']);
	ps.write('\u0006');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle meta', async t => {
	const ps = term('use-input', ['meta']);
	ps.write('\u001Bm');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle up arrow', async t => {
	const ps = term('use-input', ['upArrow']);
	ps.write('\u001B[A');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle down arrow', async t => {
	const ps = term('use-input', ['downArrow']);
	ps.write('\u001B[B');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle left arrow', async t => {
	const ps = term('use-input', ['leftArrow']);
	ps.write('\u001B[D');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle right arrow', async t => {
	const ps = term('use-input', ['rightArrow']);
	ps.write('\u001B[C');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle meta + up arrow', async t => {
	const ps = term('use-input', ['upArrowMeta']);
	ps.write('\u001B\u001B[A');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle meta + down arrow', async t => {
	const ps = term('use-input', ['downArrowMeta']);
	ps.write('\u001B\u001B[B');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle meta + left arrow', async t => {
	const ps = term('use-input', ['leftArrowMeta']);
	ps.write('\u001B\u001B[D');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle meta + right arrow', async t => {
	const ps = term('use-input', ['rightArrowMeta']);
	ps.write('\u001B\u001B[C');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle ctrl + up arrow', async t => {
	const ps = term('use-input', ['upArrowCtrl']);
	ps.write('\u001B[1;5A');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle ctrl + down arrow', async t => {
	const ps = term('use-input', ['downArrowCtrl']);
	ps.write('\u001B[1;5B');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle ctrl + left arrow', async t => {
	const ps = term('use-input', ['leftArrowCtrl']);
	ps.write('\u001B[1;5D');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle ctrl + right arrow', async t => {
	const ps = term('use-input', ['rightArrowCtrl']);
	ps.write('\u001B[1;5C');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle page down', async t => {
	const ps = term('use-input', ['pageDown']);
	ps.write('\u001B[6~');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle page up', async t => {
	const ps = term('use-input', ['pageUp']);
	ps.write('\u001B[5~');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle tab', async t => {
	const ps = term('use-input', ['tab']);
	ps.write('\t');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle shift + tab', async t => {
	const ps = term('use-input', ['shiftTab']);
	ps.write('\u001B[Z');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle backspace', async t => {
	const ps = term('use-input', ['backspace']);
	ps.write('\u0008');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle delete', async t => {
	const ps = term('use-input', ['delete']);
	ps.write('\u007F');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - handle remove (delete)', async t => {
	const ps = term('use-input', ['remove']);
	ps.write('\u001B[3~');
	await ps.waitForExit();
	t.true(ps.output.includes('exited'));
});

test.serial('useInput - ignore input if not active', async t => {
	const ps = term('use-input-multiple');
	ps.write('x');
	await ps.waitForExit();
	t.false(ps.output.includes('xx'));
	t.true(ps.output.includes('x'));
	t.true(ps.output.includes('exited'));
});

// For some reason this test is flaky, so we have to resort to using `t.try` to run it multiple times
test.serial(
	'useInput - handle Ctrl+C when `exitOnCtrlC` is `false`',
	async t => {
		const run = async (tt: ExecutionContext) => {
			const ps = term('use-input-ctrl-c');
			ps.write('\u0003');
			await ps.waitForExit();
			tt.true(ps.output.includes('exited'));
		};

		const firstTry = await t.try(run);

		if (firstTry.passed) {
			firstTry.commit();
			return;
		}

		firstTry.discard();

		const secondTry = await t.try(run);

		if (secondTry.passed) {
			secondTry.commit();
			return;
		}

		secondTry.discard();

		const thirdTry = await t.try(run);
		thirdTry.commit();
	},
);

test.serial('useStdout - write to stdout', async t => {
	const ps = term('use-stdout');
	await ps.waitForExit();

	const lines = stripAnsi(ps.output).split('\r\n');

	t.deepEqual(lines.slice(1, -1), [
		'Hello from Ink to stdout',
		'Hello World',
		'exited',
	]);
});

// `node-pty` doesn't support streaming stderr output, so I need to figure out
// how to test useStderr() hook. child_process.spawn() can't be used, because
// Ink fails with "raw mode unsupported" error.
test.todo('useStderr - write to stderr');



================================================
FILE: test/margin.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('margin', t => {
	const output = renderToString(
		<Box margin={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\n  X\n\n');
});

test('margin X', t => {
	const output = renderToString(
		<Box>
			<Box marginX={2}>
				<Text>X</Text>
			</Box>
			<Text>Y</Text>
		</Box>,
	);

	t.is(output, '  X  Y');
});

test('margin Y', t => {
	const output = renderToString(
		<Box marginY={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\nX\n\n');
});

test('margin top', t => {
	const output = renderToString(
		<Box marginTop={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\nX');
});

test('margin bottom', t => {
	const output = renderToString(
		<Box marginBottom={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, 'X\n\n');
});

test('margin left', t => {
	const output = renderToString(
		<Box marginLeft={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '  X');
});

test('margin right', t => {
	const output = renderToString(
		<Box>
			<Box marginRight={2}>
				<Text>X</Text>
			</Box>
			<Text>Y</Text>
		</Box>,
	);

	t.is(output, 'X  Y');
});

test('nested margin', t => {
	const output = renderToString(
		<Box margin={2}>
			<Box margin={2}>
				<Text>X</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\n\n\n    X\n\n\n\n');
});

test('margin with multiline string', t => {
	const output = renderToString(
		<Box margin={2}>
			<Text>{'A\nB'}</Text>
		</Box>,
	);

	t.is(output, '\n\n  A\n  B\n\n');
});

test('apply margin to text with newlines', t => {
	const output = renderToString(
		<Box margin={1}>
			<Text>Hello{'\n'}World</Text>
		</Box>,
	);
	t.is(output, '\n Hello\n World\n');
});

test('apply margin to wrapped text', t => {
	const output = renderToString(
		<Box margin={1} width={6}>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, '\n Hello\n World\n');
});



================================================
FILE: test/measure-element.tsx
================================================
import React, {useState, useRef, useEffect} from 'react';
import test from 'ava';
import delay from 'delay';
import stripAnsi from 'strip-ansi';
import {
	Box,
	Text,
	render,
	measureElement,
	type DOMElement,
} from '../src/index.js';
import createStdout from './helpers/create-stdout.js';

test('measure element', async t => {
	const stdout = createStdout();

	function Test() {
		const [width, setWidth] = useState(0);
		const ref = useRef<DOMElement>(null);

		useEffect(() => {
			if (!ref.current) {
				return;
			}

			setWidth(measureElement(ref.current).width);
		}, []);

		return (
			<Box ref={ref}>
				<Text>Width: {width}</Text>
			</Box>
		);
	}

	render(<Test />, {stdout, debug: true});
	t.is((stdout.write as any).firstCall.args[0], 'Width: 0');
	await delay(100);
	t.is((stdout.write as any).lastCall.args[0], 'Width: 100');
});

test.serial('calculate layout while rendering is throttled', async t => {
	const stdout = createStdout();

	function Test() {
		const [width, setWidth] = useState(0);
		const ref = useRef<DOMElement>(null);

		useEffect(() => {
			if (!ref.current) {
				return;
			}

			setWidth(measureElement(ref.current).width);
		}, []);

		return (
			<Box ref={ref}>
				<Text>Width: {width}</Text>
			</Box>
		);
	}

	const {rerender} = render(null, {stdout, patchConsole: false});
	rerender(<Test />);
	await delay(50);

	t.is(
		stripAnsi((stdout.write as any).lastCall.firstArg as string).trim(),
		'Width: 100',
	);
});



================================================
FILE: test/measure-text.tsx
================================================
import test from 'ava';
import measureText from '../src/measure-text.js';

test('measure "constructor"', t => {
	const {width} = measureText('constructor');
	t.is(width, 11);
});



================================================
FILE: test/overflow.tsx
================================================
import React from 'react';
import test from 'ava';
import boxen, {type Options} from 'boxen';
import sliceAnsi from 'slice-ansi';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

const box = (text: string, options?: Options): string => {
	return boxen(text, {
		...options,
		borderStyle: 'round',
	});
};

const clipX = (text: string, columns: number): string => {
	return text
		.split('\n')
		.map(line => sliceAnsi(line, 0, columns).trim())
		.join('\n');
};

test('overflowX - single text node in a box inside overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box width={16} flexShrink={0}>
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'Hello');
});

test('overflowX - single text node inside overflow container with border', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden" borderStyle="round">
			<Box width={16} flexShrink={0}>
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('Hell'));
});

test('overflowX - single text node in a box with border inside overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box width={16} flexShrink={0} borderStyle="round">
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, clipX(box('Hello'), 6));
});

test('overflowX - multiple text nodes in a box inside overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box width={12} flexShrink={0}>
				<Text>Hello </Text>
				<Text>World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'Hello');
});

test('overflowX - multiple text nodes in a box inside overflow container with border', t => {
	const output = renderToString(
		<Box width={8} overflowX="hidden" borderStyle="round">
			<Box width={12} flexShrink={0}>
				<Text>Hello </Text>
				<Text>World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('Hello '));
});

test('overflowX - multiple text nodes in a box with border inside overflow container', t => {
	const output = renderToString(
		<Box width={8} overflowX="hidden">
			<Box width={12} flexShrink={0} borderStyle="round">
				<Text>Hello </Text>
				<Text>World</Text>
			</Box>
		</Box>,
	);

	t.is(output, clipX(box('HelloWo\n'), 8));
});

test('overflowX - multiple boxes inside overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box width={6} flexShrink={0}>
				<Text>Hello </Text>
			</Box>
			<Box width={6} flexShrink={0}>
				<Text>World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'Hello');
});

test('overflowX - multiple boxes inside overflow container with border', t => {
	const output = renderToString(
		<Box width={8} overflowX="hidden" borderStyle="round">
			<Box width={6} flexShrink={0}>
				<Text>Hello </Text>
			</Box>
			<Box width={6} flexShrink={0}>
				<Text>World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('Hello '));
});

test('overflowX - box before left edge of overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box marginLeft={-12} width={6} flexShrink={0}>
				<Text>Hello</Text>
			</Box>
		</Box>,
	);

	t.is(output, '');
});

test('overflowX - box before left edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden" borderStyle="round">
			<Box marginLeft={-12} width={6} flexShrink={0}>
				<Text>Hello</Text>
			</Box>
		</Box>,
	);

	t.is(output, box(' '.repeat(4)));
});

test('overflowX - box intersecting with left edge of overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box marginLeft={-3} width={12} flexShrink={0}>
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'lo Wor');
});

test('overflowX - box intersecting with left edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={8} overflowX="hidden" borderStyle="round">
			<Box marginLeft={-3} width={12} flexShrink={0}>
				<Text>Hello World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('lo Wor'));
});

test('overflowX - box after right edge of overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box marginLeft={6} width={6} flexShrink={0}>
				<Text>Hello</Text>
			</Box>
		</Box>,
	);

	t.is(output, '');
});

test('overflowX - box intersecting with right edge of overflow container', t => {
	const output = renderToString(
		<Box width={6} overflowX="hidden">
			<Box marginLeft={3} width={6} flexShrink={0}>
				<Text>Hello</Text>
			</Box>
		</Box>,
	);

	t.is(output, '   Hel');
});

test('overflowY - single text node inside overflow container', t => {
	const output = renderToString(
		<Box height={1} overflowY="hidden">
			<Text>Hello{'\n'}World</Text>
		</Box>,
	);

	t.is(output, 'Hello');
});

test('overflowY - single text node inside overflow container with border', t => {
	const output = renderToString(
		<Box width={20} height={3} overflowY="hidden" borderStyle="round">
			<Text>Hello{'\n'}World</Text>
		</Box>,
	);

	t.is(output, box('Hello'.padEnd(18, ' ')));
});

test('overflowY - multiple boxes inside overflow container', t => {
	const output = renderToString(
		<Box height={2} overflowY="hidden" flexDirection="column">
			<Box flexShrink={0}>
				<Text>Line #1</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #2</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #3</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #4</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'Line #1\nLine #2');
});

test('overflowY - multiple boxes inside overflow container with border', t => {
	const output = renderToString(
		<Box
			width={9}
			height={4}
			overflowY="hidden"
			flexDirection="column"
			borderStyle="round"
		>
			<Box flexShrink={0}>
				<Text>Line #1</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #2</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #3</Text>
			</Box>
			<Box flexShrink={0}>
				<Text>Line #4</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('Line #1\nLine #2'));
});

test('overflowY - box above top edge of overflow container', t => {
	const output = renderToString(
		<Box height={1} overflowY="hidden">
			<Box marginTop={-2} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, '');
});

test('overflowY - box above top edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={7} height={3} overflowY="hidden" borderStyle="round">
			<Box marginTop={-3} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box(' '.repeat(5)));
});

test('overflowY - box intersecting with top edge of overflow container', t => {
	const output = renderToString(
		<Box height={1} overflowY="hidden">
			<Box marginTop={-1} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'World');
});

test('overflowY - box intersecting with top edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={7} height={3} overflowY="hidden" borderStyle="round">
			<Box marginTop={-1} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('World'));
});

test('overflowY - box below bottom edge of overflow container', t => {
	const output = renderToString(
		<Box height={1} overflowY="hidden">
			<Box marginTop={1} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, '');
});

test('overflowY - box below bottom edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={7} height={3} overflowY="hidden" borderStyle="round">
			<Box marginTop={2} height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box(' '.repeat(5)));
});

test('overflowY - box intersecting with bottom edge of overflow container', t => {
	const output = renderToString(
		<Box height={1} overflowY="hidden">
			<Box height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'Hello');
});

test('overflowY - box intersecting with bottom edge of overflow container with border', t => {
	const output = renderToString(
		<Box width={7} height={3} overflowY="hidden" borderStyle="round">
			<Box height={2} flexShrink={0}>
				<Text>Hello{'\n'}World</Text>
			</Box>
		</Box>,
	);

	t.is(output, box('Hello'));
});

test('overflow - single text node inside overflow container', t => {
	const output = renderToString(
		<Box paddingBottom={1}>
			<Box width={6} height={1} overflow="hidden">
				<Box width={12} height={2} flexShrink={0}>
					<Text>Hello{'\n'}World</Text>
				</Box>
			</Box>
		</Box>,
	);

	t.is(output, 'Hello\n');
});

test('overflow - single text node inside overflow container with border', t => {
	const output = renderToString(
		<Box paddingBottom={1}>
			<Box width={8} height={3} overflow="hidden" borderStyle="round">
				<Box width={12} height={2} flexShrink={0}>
					<Text>Hello{'\n'}World</Text>
				</Box>
			</Box>
		</Box>,
	);

	t.is(output, `${box('Hello ')}\n`);
});

test('overflow - multiple boxes inside overflow container', t => {
	const output = renderToString(
		<Box paddingBottom={1}>
			<Box width={4} height={1} overflow="hidden">
				<Box width={2} height={2} flexShrink={0}>
					<Text>TL{'\n'}BL</Text>
				</Box>
				<Box width={2} height={2} flexShrink={0}>
					<Text>TR{'\n'}BR</Text>
				</Box>
			</Box>
		</Box>,
	);

	t.is(output, 'TLTR\n');
});

test('overflow - multiple boxes inside overflow container with border', t => {
	const output = renderToString(
		<Box paddingBottom={1}>
			<Box width={6} height={3} overflow="hidden" borderStyle="round">
				<Box width={2} height={2} flexShrink={0}>
					<Text>TL{'\n'}BL</Text>
				</Box>
				<Box width={2} height={2} flexShrink={0}>
					<Text>TR{'\n'}BR</Text>
				</Box>
			</Box>
		</Box>,
	);

	t.is(output, `${box('TLTR')}\n`);
});

test('overflow - box intersecting with top left edge of overflow container', t => {
	const output = renderToString(
		<Box width={4} height={4} overflow="hidden">
			<Box marginTop={-2} marginLeft={-2} width={4} height={4} flexShrink={0}>
				<Text>
					AAAA{'\n'}BBBB{'\n'}CCCC{'\n'}DDDD
				</Text>
			</Box>
		</Box>,
	);

	t.is(output, 'CC\nDD\n\n');
});

test('overflow - box intersecting with top right edge of overflow container', t => {
	const output = renderToString(
		<Box width={4} height={4} overflow="hidden">
			<Box marginTop={-2} marginLeft={2} width={4} height={4} flexShrink={0}>
				<Text>
					AAAA{'\n'}BBBB{'\n'}CCCC{'\n'}DDDD
				</Text>
			</Box>
		</Box>,
	);

	t.is(output, '  CC\n  DD\n\n');
});

test('overflow - box intersecting with bottom left edge of overflow container', t => {
	const output = renderToString(
		<Box width={4} height={4} overflow="hidden">
			<Box marginTop={2} marginLeft={-2} width={4} height={4} flexShrink={0}>
				<Text>
					AAAA{'\n'}BBBB{'\n'}CCCC{'\n'}DDDD
				</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\nAA\nBB');
});

test('overflow - box intersecting with bottom right edge of overflow container', t => {
	const output = renderToString(
		<Box width={4} height={4} overflow="hidden">
			<Box marginTop={2} marginLeft={2} width={4} height={4} flexShrink={0}>
				<Text>
					AAAA{'\n'}BBBB{'\n'}CCCC{'\n'}DDDD
				</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\n  AA\n  BB');
});

test('nested overflow', t => {
	const output = renderToString(
		<Box paddingBottom={1}>
			<Box width={4} height={4} overflow="hidden" flexDirection="column">
				<Box width={2} height={2} overflow="hidden">
					<Box width={4} height={4} flexShrink={0}>
						<Text>
							AAAA{'\n'}BBBB{'\n'}CCCC{'\n'}DDDD
						</Text>
					</Box>
				</Box>

				<Box width={4} height={3}>
					<Text>
						XXXX{'\n'}YYYY{'\n'}ZZZZ
					</Text>
				</Box>
			</Box>
		</Box>,
	);

	t.is(output, 'AA\nBB\nXXXX\nYYYY\n');
});

// See https://github.com/vadimdemedes/ink/pull/564#issuecomment-1637022742
test('out of bounds writes do not crash', t => {
	const output = renderToString(
		<Box width={12} height={10} borderStyle="round" />,
		{columns: 10},
	);

	const expected = boxen('', {
		width: 12,
		height: 10,
		borderStyle: 'round',
	})
		.split('\n')
		.map((line, index) => {
			return index === 0 || index === 9
				? line
				: `${line.slice(0, 10)}${line[11] ?? ''}`;
		})
		.join('\n');

	t.is(output, expected);
});



================================================
FILE: test/padding.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('padding', t => {
	const output = renderToString(
		<Box padding={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\n  X\n\n');
});

test('padding X', t => {
	const output = renderToString(
		<Box>
			<Box paddingX={2}>
				<Text>X</Text>
			</Box>
			<Text>Y</Text>
		</Box>,
	);

	t.is(output, '  X  Y');
});

test('padding Y', t => {
	const output = renderToString(
		<Box paddingY={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\nX\n\n');
});

test('padding top', t => {
	const output = renderToString(
		<Box paddingTop={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '\n\nX');
});

test('padding bottom', t => {
	const output = renderToString(
		<Box paddingBottom={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, 'X\n\n');
});

test('padding left', t => {
	const output = renderToString(
		<Box paddingLeft={2}>
			<Text>X</Text>
		</Box>,
	);

	t.is(output, '  X');
});

test('padding right', t => {
	const output = renderToString(
		<Box>
			<Box paddingRight={2}>
				<Text>X</Text>
			</Box>
			<Text>Y</Text>
		</Box>,
	);

	t.is(output, 'X  Y');
});

test('nested padding', t => {
	const output = renderToString(
		<Box padding={2}>
			<Box padding={2}>
				<Text>X</Text>
			</Box>
		</Box>,
	);

	t.is(output, '\n\n\n\n    X\n\n\n\n');
});

test('padding with multiline string', t => {
	const output = renderToString(
		<Box padding={2}>
			<Text>{'A\nB'}</Text>
		</Box>,
	);

	t.is(output, '\n\n  A\n  B\n\n');
});

test('apply padding to text with newlines', t => {
	const output = renderToString(
		<Box padding={1}>
			<Text>Hello{'\n'}World</Text>
		</Box>,
	);
	t.is(output, '\n Hello\n World\n');
});

test('apply padding to wrapped text', t => {
	const output = renderToString(
		<Box padding={1} width={5}>
			<Text>Hello World</Text>
		</Box>,
	);

	t.is(output, '\n Hel\n lo\n Wor\n ld\n');
});



================================================
FILE: test/reconciler.tsx
================================================
import React, {Suspense} from 'react';
import test from 'ava';
import chalk from 'chalk';
import {Box, Text, render} from '../src/index.js';
import createStdout from './helpers/create-stdout.js';

test('update child', t => {
	function Test({update}: {readonly update?: boolean}) {
		return <Text>{update ? 'B' : 'A'}</Text>;
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(<Text>A</Text>, {
		stdout: stdoutExpected,
		debug: true,
	});

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test update />);
	expected.rerender(<Text>B</Text>);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('update text node', t => {
	function Test({update}: {readonly update?: boolean}) {
		return (
			<Box>
				<Text>Hello </Text>
				<Text>{update ? 'B' : 'A'}</Text>
			</Box>
		);
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(<Text>Hello A</Text>, {
		stdout: stdoutExpected,
		debug: true,
	});

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test update />);
	expected.rerender(<Text>Hello B</Text>);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('append child', t => {
	function Test({append}: {readonly append?: boolean}) {
		if (append) {
			return (
				<Box flexDirection="column">
					<Text>A</Text>
					<Text>B</Text>
				</Box>
			);
		}

		return (
			<Box flexDirection="column">
				<Text>A</Text>
			</Box>
		);
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(
		<Box flexDirection="column">
			<Text>A</Text>
		</Box>,
		{
			stdout: stdoutExpected,
			debug: true,
		},
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test append />);

	expected.rerender(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('insert child between other children', t => {
	function Test({insert}: {readonly insert?: boolean}) {
		if (insert) {
			return (
				<Box flexDirection="column">
					<Text key="a">A</Text>
					<Text key="b">B</Text>
					<Text key="c">C</Text>
				</Box>
			);
		}

		return (
			<Box flexDirection="column">
				<Text key="a">A</Text>
				<Text key="c">C</Text>
			</Box>
		);
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>C</Text>
		</Box>,
		{
			stdout: stdoutExpected,
			debug: true,
		},
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test insert />);

	expected.rerender(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>,
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('remove child', t => {
	function Test({remove}: {readonly remove?: boolean}) {
		if (remove) {
			return (
				<Box flexDirection="column">
					<Text>A</Text>
				</Box>
			);
		}

		return (
			<Box flexDirection="column">
				<Text>A</Text>
				<Text>B</Text>
			</Box>
		);
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
		{
			stdout: stdoutExpected,
			debug: true,
		},
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test remove />);

	expected.rerender(
		<Box flexDirection="column">
			<Text>A</Text>
		</Box>,
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('reorder children', t => {
	function Test({reorder}: {readonly reorder?: boolean}) {
		if (reorder) {
			return (
				<Box flexDirection="column">
					<Text key="b">B</Text>
					<Text key="a">A</Text>
				</Box>
			);
		}

		return (
			<Box flexDirection="column">
				<Text key="a">A</Text>
				<Text key="b">B</Text>
			</Box>
		);
	}

	const stdoutActual = createStdout();
	const stdoutExpected = createStdout();

	const actual = render(<Test />, {
		stdout: stdoutActual,
		debug: true,
	});

	const expected = render(
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
		{
			stdout: stdoutExpected,
			debug: true,
		},
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);

	actual.rerender(<Test reorder />);

	expected.rerender(
		<Box flexDirection="column">
			<Text>B</Text>
			<Text>A</Text>
		</Box>,
	);

	t.is(
		(stdoutActual.write as any).lastCall.args[0],
		(stdoutExpected.write as any).lastCall.args[0],
	);
});

test('replace child node with text', t => {
	const stdout = createStdout();

	function Dynamic({replace}: {readonly replace?: boolean}) {
		return <Text>{replace ? 'x' : <Text color="green">test</Text>}</Text>;
	}

	const {rerender} = render(<Dynamic />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], chalk.green('test'));

	rerender(<Dynamic replace />);
	t.is((stdout.write as any).lastCall.args[0], 'x');
});

test('support suspense', async t => {
	const stdout = createStdout();

	let promise: Promise<void> | undefined;
	let state: 'pending' | 'done' | undefined;
	let value: string | undefined;

	const read = () => {
		if (!promise) {
			promise = new Promise(resolve => {
				setTimeout(resolve, 500);
			});

			state = 'pending';

			(async () => {
				await promise;
				state = 'done';
				value = 'Hello World';
			})();
		}

		if (state === 'done') {
			return value;
		}

		// eslint-disable-next-line @typescript-eslint/only-throw-error
		throw promise;
	};

	function Suspendable() {
		return <Text>{read()}</Text>;
	}

	function Test() {
		return (
			<Suspense fallback={<Text>Loading</Text>}>
				<Suspendable />
			</Suspense>
		);
	}

	const out = render(<Test />, {
		stdout,
		debug: true,
	});

	t.is((stdout.write as any).lastCall.args[0], 'Loading');

	await promise;
	out.rerender(<Test />);

	t.is((stdout.write as any).lastCall.args[0], 'Hello World');
});



================================================
FILE: test/render.tsx
================================================
import EventEmitter from 'node:events';
import process from 'node:process';
import url from 'node:url';
import * as path from 'node:path';
import {createRequire} from 'node:module';
import FakeTimers from '@sinonjs/fake-timers';
import {stub} from 'sinon';
import test from 'ava';
import React, {type ReactNode, useEffect, useState} from 'react';
import ansiEscapes from 'ansi-escapes';
import stripAnsi from 'strip-ansi';
import boxen from 'boxen';
import delay from 'delay';
import {render, Box, Text, useInput} from '../src/index.js';
import {type RenderMetrics} from '../src/ink.js';
import createStdout from './helpers/create-stdout.js';

const require = createRequire(import.meta.url);

// eslint-disable-next-line @typescript-eslint/consistent-type-imports
const {spawn} = require('node-pty') as typeof import('node-pty');

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

const createStdin = () => {
	const stdin = new EventEmitter() as unknown as NodeJS.WriteStream;
	stdin.isTTY = true;
	stdin.setRawMode = stub();
	stdin.setEncoding = () => {};
	stdin.read = stub();
	stdin.unref = () => {};
	stdin.ref = () => {};

	return stdin;
};

const emitReadable = (stdin: NodeJS.WriteStream, chunk: string) => {
	/* eslint-disable @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment */
	const read = stdin.read as ReturnType<typeof stub>;
	read.onCall(0).returns(chunk);
	read.onCall(1).returns(null);
	stdin.emit('readable');
	read.reset();
	/* eslint-enable @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment */
};

const term = (fixture: string, args: string[] = []) => {
	let resolve: (value?: unknown) => void;
	let reject: (error: Error) => void;

	// eslint-disable-next-line promise/param-names
	const exitPromise = new Promise((resolve2, reject2) => {
		resolve = resolve2;
		reject = reject2;
	});

	const env = {
		...process.env,
		// eslint-disable-next-line @typescript-eslint/naming-convention
		NODE_NO_WARNINGS: '1',
	};

	const ps = spawn(
		'node',
		[
			'--loader=ts-node/esm',
			path.join(__dirname, `./fixtures/${fixture}.tsx`),
			...args,
		],
		{
			name: 'xterm-color',
			cols: 100,
			cwd: __dirname,
			env,
		},
	);

	const result = {
		write(input: string) {
			ps.write(input);
		},
		output: '',
		waitForExit: async () => exitPromise,
	};

	ps.onData(data => {
		result.output += data;
	});

	ps.onExit(({exitCode}) => {
		if (exitCode === 0) {
			resolve();
			return;
		}

		reject(new Error(`Process exited with non-zero exit code: ${exitCode}`));
	});

	return result;
};

test.serial('do not erase screen', async t => {
	const ps = term('erase', ['4']);
	await ps.waitForExit();
	t.false(ps.output.includes(ansiEscapes.clearTerminal));

	for (const letter of ['A', 'B', 'C']) {
		t.true(ps.output.includes(letter));
	}
});

test.serial(
	'do not erase screen where <Static> is taller than viewport',
	async t => {
		const ps = term('erase-with-static', ['4']);

		await ps.waitForExit();
		t.false(ps.output.includes(ansiEscapes.clearTerminal));

		for (const letter of ['A', 'B', 'C', 'D', 'E', 'F']) {
			t.true(ps.output.includes(letter));
		}
	},
);

test.serial('erase screen', async t => {
	const ps = term('erase', ['3']);
	await ps.waitForExit();
	t.true(ps.output.includes(ansiEscapes.clearTerminal));

	for (const letter of ['A', 'B', 'C']) {
		t.true(ps.output.includes(letter));
	}
});

test.serial(
	'erase screen where <Static> exists but interactive part is taller than viewport',
	async t => {
		const ps = term('erase', ['3']);
		await ps.waitForExit();
		t.true(ps.output.includes(ansiEscapes.clearTerminal));

		for (const letter of ['A', 'B', 'C']) {
			t.true(ps.output.includes(letter));
		}
	},
);

test.serial('erase screen where state changes', async t => {
	const ps = term('erase-with-state-change', ['4']);
	await ps.waitForExit();

	const secondFrame = ps.output.split(ansiEscapes.eraseLines(3))[1];

	for (const letter of ['A', 'B', 'C']) {
		t.false(secondFrame?.includes(letter));
	}
});

test.serial('erase screen where state changes in small viewport', async t => {
	const ps = term('erase-with-state-change', ['3']);
	await ps.waitForExit();

	const frames = ps.output.split(ansiEscapes.clearTerminal);
	const lastFrame = frames.at(-1);

	for (const letter of ['A', 'B', 'C']) {
		t.false(lastFrame?.includes(letter));
	}
});

test.serial(
	'fullscreen mode should not add extra newline at the bottom',
	async t => {
		const ps = term('fullscreen-no-extra-newline', ['5']);
		await ps.waitForExit();

		t.true(ps.output.includes('Bottom line'));

		const lastFrame = ps.output.split(ansiEscapes.clearTerminal).at(-1) ?? '';

		// Check that the bottom line is at the end without extra newlines
		// In a 5-line terminal:
		// Line 1: Fullscreen: top
		// Lines 2-4: empty (from flexGrow)
		// Line 5: Bottom line (should be usable)
		const lines = lastFrame.split('\n');

		t.is(lines.length, 5, 'Should have exactly 5 lines for 5-row terminal');

		t.true(
			lines[4]?.includes('Bottom line') ?? false,
			'Bottom line should be on line 5',
		);
	},
);

test.serial('clear output', async t => {
	const ps = term('clear');
	await ps.waitForExit();

	const secondFrame = ps.output.split(ansiEscapes.eraseLines(4))[1];

	for (const letter of ['A', 'B', 'C']) {
		t.false(secondFrame?.includes(letter));
	}
});

test.serial(
	'intercept console methods and display result above output',
	async t => {
		const ps = term('console');
		await ps.waitForExit();

		const frames = ps.output.split(ansiEscapes.eraseLines(2)).map(line => {
			return stripAnsi(line);
		});

		t.deepEqual(frames, [
			'Hello World\r\n',
			'First log\r\nHello World\r\nSecond log\r\n',
		]);
	},
);

test.serial('rerender on resize', async t => {
	const stdout = createStdout(10);

	function Test() {
		return (
			<Box borderStyle="round">
				<Text>Test</Text>
			</Box>
		);
	}

	const {unmount} = render(<Test />, {stdout});

	t.is(
		stripAnsi((stdout.write as any).firstCall.args[0] as string),
		boxen('Test'.padEnd(8), {borderStyle: 'round'}) + '\n',
	);

	t.is(stdout.listeners('resize').length, 1);

	stdout.columns = 8;
	stdout.emit('resize');
	await delay(100);

	t.is(
		stripAnsi((stdout.write as any).lastCall.args[0] as string),
		boxen('Test'.padEnd(6), {borderStyle: 'round'}) + '\n',
	);

	unmount();
	t.is(stdout.listeners('resize').length, 0);
});

function ThrottleTestComponent({text}: {readonly text: string}) {
	return <Text>{text}</Text>;
}

test.serial('throttle renders to maxFps', t => {
	const clock = FakeTimers.install(); // Controls timers + Date.now()
	try {
		const stdout = createStdout();

		const {unmount, rerender} = render(<ThrottleTestComponent text="Hello" />, {
			stdout,
			maxFps: 1, // 1 Hz => ~1000 ms window
		});

		// Initial render (leading call)
		t.is((stdout.write as any).callCount, 1);
		t.is(
			stripAnsi((stdout.write as any).lastCall.args[0] as string),
			'Hello\n',
		);

		// Trigger another render inside the throttle window
		rerender(<ThrottleTestComponent text="World" />);
		t.is((stdout.write as any).callCount, 1);

		// Advance 999 ms: still within window, no trailing call yet
		clock.tick(999);
		t.is((stdout.write as any).callCount, 1);

		// Cross the boundary: trailing render fires once
		clock.tick(1);
		t.is((stdout.write as any).callCount, 2);
		t.is(
			stripAnsi((stdout.write as any).lastCall.args[0] as string),
			'World\n',
		);

		unmount();
	} finally {
		clock.uninstall();
	}
});

test.serial('outputs renderTime when onRender is passed', async t => {
	const renderTimes: number[] = [];
	const funcObj = {
		onRender(metrics: RenderMetrics) {
			const {renderTime} = metrics;
			renderTimes.push(renderTime);
		},
	};

	const onRenderStub = stub(funcObj, 'onRender').callThrough();

	function Test({children}: {readonly children?: ReactNode}) {
		const [text, setText] = useState('Test');

		useInput(input => {
			setText(input);
		});

		return (
			<Box borderStyle="round">
				<Text>{text}</Text>
				{children}
			</Box>
		);
	}

	const stdin = createStdin();
	const {unmount, rerender} = render(<Test />, {
		onRender: onRenderStub,
		stdin,
	});

	// Initial render
	t.is(onRenderStub.callCount, 1);
	t.true(renderTimes[0] >= 0);

	// Manual rerender
	onRenderStub.resetHistory();
	rerender(
		<Test>
			<Text>Updated</Text>
		</Test>,
	);
	await delay(100);
	t.is(onRenderStub.callCount, 1);
	t.true(renderTimes[1] >= 0);

	// Internal state update via useInput
	onRenderStub.resetHistory();
	emitReadable(stdin, 'a');
	await delay(100);
	t.is(onRenderStub.callCount, 1);
	t.true(renderTimes[2] >= 0);

	// Verify all renders were tracked
	t.is(renderTimes.length, 3);

	unmount();
});

test.serial('no throttled renders after unmount', t => {
	const clock = FakeTimers.install();
	try {
		const stdout = createStdout();

		const {unmount, rerender} = render(<ThrottleTestComponent text="Foo" />, {
			stdout,
		});

		t.is((stdout.write as any).callCount, 1);

		rerender(<ThrottleTestComponent text="Bar" />);
		rerender(<ThrottleTestComponent text="Baz" />);
		unmount();

		// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
		const callCountAfterUnmount = (stdout.write as any).callCount;

		// Regression test for https://github.com/vadimdemedes/ink/issues/692
		clock.tick(1000);
		t.is((stdout.write as any).callCount, callCountAfterUnmount);
	} finally {
		clock.uninstall();
	}
});



================================================
FILE: test/screen-reader.tsx
================================================
import test from 'ava';
import React from 'react';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('render text for screen readers', t => {
	const output = renderToString(
		<Box aria-label="Hello World">
			<Text>Not visible to screen readers</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Hello World');
});

test('render text for screen readers with aria-hidden', t => {
	const output = renderToString(
		<Box aria-hidden>
			<Text>Not visible to screen readers</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, '');
});

test('render text for screen readers with aria-role', t => {
	const output = renderToString(
		<Box aria-role="button">
			<Text>Click me</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'button: Click me');
});

test('render select input for screen readers', t => {
	const items = ['Red', 'Green', 'Blue'];

	const output = renderToString(
		<Box aria-role="list" flexDirection="column">
			<Text>Select a color:</Text>
			{items.map((item, index) => {
				const isSelected = index === 1;
				const screenReaderLabel = `${index + 1}. ${item}`;

				return (
					<Box
						key={item}
						aria-label={screenReaderLabel}
						aria-role="listitem"
						aria-state={{selected: isSelected}}
					>
						<Text>{item}</Text>
					</Box>
				);
			})}
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(
		output,
		'list: Select a color:\nlistitem: 1. Red\nlistitem: (selected) 2. Green\nlistitem: 3. Blue',
	);
});

test('render aria-label only Text for screen readers', t => {
	const output = renderToString(<Text aria-label="Screen-reader only" />, {
		isScreenReaderEnabled: true,
	});

	t.is(output, 'Screen-reader only');
});

test('render aria-label only Box for screen readers', t => {
	const output = renderToString(<Box aria-label="Screen-reader only" />, {
		isScreenReaderEnabled: true,
	});

	t.is(output, 'Screen-reader only');
});

test('omit ANSI styling in screen-reader output', t => {
	const output = renderToString(
		<Box>
			{/* eslint-disable-next-line react/jsx-sort-props */}
			<Text bold color="green" inverse underline>
				Styled content
			</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Styled content');
});

test('skip nodes with display:none style in screen-reader output', t => {
	const output = renderToString(
		<Box>
			<Box display="none">
				<Text>Hidden</Text>
			</Box>
			<Text>Visible</Text>
		</Box>,
		{isScreenReaderEnabled: true},
	);

	t.is(output, 'Visible');
});

test('render multiple Text components', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>Hello</Text>
			<Text>World</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Hello\nWorld');
});

test('render nested Box components with Text', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>Hello</Text>
			<Box>
				<Text>World</Text>
			</Box>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Hello\nWorld');
});

function NullComponent(): undefined {
	return undefined;
}

test('render component that returns null', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>Hello</Text>
			<NullComponent />
			<Text>World</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Hello\nWorld');
});

test('render with aria-state.busy', t => {
	const output = renderToString(
		<Box aria-state={{busy: true}}>
			<Text>Loading</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, '(busy) Loading');
});

test('render with aria-state.checked', t => {
	const output = renderToString(
		<Box aria-role="checkbox" aria-state={{checked: true}}>
			<Text>Accept terms</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'checkbox: (checked) Accept terms');
});

test('render with aria-state.disabled', t => {
	const output = renderToString(
		<Box aria-role="button" aria-state={{disabled: true}}>
			<Text>Submit</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'button: (disabled) Submit');
});

test('render with aria-state.expanded', t => {
	const output = renderToString(
		<Box aria-role="combobox" aria-state={{expanded: true}}>
			<Text>Select</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'combobox: (expanded) Select');
});

test('render with aria-state.multiline', t => {
	const output = renderToString(
		<Box aria-role="textbox" aria-state={{multiline: true}}>
			<Text>Hello</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'textbox: (multiline) Hello');
});

test('render with aria-state.multiselectable', t => {
	const output = renderToString(
		<Box aria-role="listbox" aria-state={{multiselectable: true}}>
			<Text>Options</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'listbox: (multiselectable) Options');
});

test('render with aria-state.readonly', t => {
	const output = renderToString(
		<Box aria-role="textbox" aria-state={{readonly: true}}>
			<Text>Hello</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'textbox: (readonly) Hello');
});

test('render with aria-state.required', t => {
	const output = renderToString(
		<Box aria-role="textbox" aria-state={{required: true}}>
			<Text>Name</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'textbox: (required) Name');
});

test('render with aria-state.selected', t => {
	const output = renderToString(
		<Box aria-role="option" aria-state={{selected: true}}>
			<Text>Blue</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'option: (selected) Blue');
});

test('render multi-line text', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Text>Line 1</Text>
			<Text>Line 2</Text>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Line 1\nLine 2');
});

test('render nested multi-line text', t => {
	const output = renderToString(
		<Box flexDirection="row">
			<Box flexDirection="column">
				<Text>Line 1</Text>
				<Text>Line 2</Text>
			</Box>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Line 1\nLine 2');
});

test('render nested row', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Box flexDirection="row">
				<Text>Line 1</Text>
				<Text>Line 2</Text>
			</Box>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'Line 1 Line 2');
});

test('render multi-line text with roles', t => {
	const output = renderToString(
		<Box flexDirection="column" aria-role="list">
			<Box aria-role="listitem">
				<Text>Item 1</Text>
			</Box>
			<Box aria-role="listitem">
				<Text>Item 2</Text>
			</Box>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(output, 'list: listitem: Item 1\nlistitem: Item 2');
});

test('render listbox with multiselectable options', t => {
	const output = renderToString(
		<Box
			flexDirection="column"
			aria-role="listbox"
			aria-state={{multiselectable: true}}
		>
			<Box aria-role="option" aria-state={{selected: true}}>
				<Text>Option 1</Text>
			</Box>
			<Box aria-role="option" aria-state={{selected: false}}>
				<Text>Option 2</Text>
			</Box>
			<Box aria-role="option" aria-state={{selected: true}}>
				<Text>Option 3</Text>
			</Box>
		</Box>,
		{
			isScreenReaderEnabled: true,
		},
	);

	t.is(
		output,
		'listbox: (multiselectable) option: (selected) Option 1\noption: Option 2\noption: (selected) Option 3',
	);
});



================================================
FILE: test/text-width.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('wide characters do not add extra space inside fixed-width Box', t => {
	const output = renderToString(
		<Box flexDirection="column">
			<Box>
				<Box width={2}>
					<Text>🍔</Text>
				</Box>
				<Text>|</Text>
			</Box>
			<Box>
				<Box width={2}>
					<Text>⏳</Text>
				</Box>
				<Text>|</Text>
			</Box>
		</Box>,
	);

	const lines = output.split('\n');
	// Both lines should have the pipe directly after the 2-column box
	t.is(lines[0], '🍔|');
	t.is(lines[1], '⏳|');
});



================================================
FILE: test/text.tsx
================================================
import React from 'react';
import test from 'ava';
import chalk from 'chalk';
import {render, Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';
import createStdout from './helpers/create-stdout.js';

test('<Text> with undefined children', t => {
	const output = renderToString(<Text />);
	t.is(output, '');
});

test('<Text> with null children', t => {
	const output = renderToString(<Text>{null}</Text>);
	t.is(output, '');
});

test('text with standard color', t => {
	const output = renderToString(<Text color="green">Test</Text>);
	t.is(output, chalk.green('Test'));
});

test('text with dim+bold', t => {
	const output = renderToString(
		<Text dimColor bold>
			Test
		</Text>,
	);
	t.is(output, chalk.bold.dim('Test'));
});

test('text with dimmed color', t => {
	const output = renderToString(
		<Text dimColor color="green">
			Test
		</Text>,
	);

	t.is(output, chalk.green.dim('Test'));
});

test('text with hex color', t => {
	const output = renderToString(<Text color="#FF8800">Test</Text>);
	t.is(output, chalk.hex('#FF8800')('Test'));
});

test('text with rgb color', t => {
	const output = renderToString(<Text color="rgb(255, 136, 0)">Test</Text>);
	t.is(output, chalk.rgb(255, 136, 0)('Test'));
});

test('text with ansi256 color', t => {
	const output = renderToString(<Text color="ansi256(194)">Test</Text>);
	t.is(output, chalk.ansi256(194)('Test'));
});

test('text with standard background color', t => {
	const output = renderToString(<Text backgroundColor="green">Test</Text>);
	t.is(output, chalk.bgGreen('Test'));
});

test('text with hex background color', t => {
	const output = renderToString(<Text backgroundColor="#FF8800">Test</Text>);
	t.is(output, chalk.bgHex('#FF8800')('Test'));
});

test('text with rgb background color', t => {
	const output = renderToString(
		<Text backgroundColor="rgb(255, 136, 0)">Test</Text>,
	);

	t.is(output, chalk.bgRgb(255, 136, 0)('Test'));
});

test('text with ansi256 background color', t => {
	const output = renderToString(
		<Text backgroundColor="ansi256(194)">Test</Text>,
	);

	t.is(output, chalk.bgAnsi256(194)('Test'));
});

test('text with inversion', t => {
	const output = renderToString(<Text inverse>Test</Text>);
	t.is(output, chalk.inverse('Test'));
});

test('remeasure text when text is changed', t => {
	function Test({add}: {readonly add?: boolean}) {
		return (
			<Box>
				<Text>{add ? 'abcx' : 'abc'}</Text>
			</Box>
		);
	}

	const stdout = createStdout();
	const {rerender} = render(<Test />, {stdout, debug: true});
	t.is((stdout.write as any).lastCall.args[0], 'abc');

	rerender(<Test add />);
	t.is((stdout.write as any).lastCall.args[0], 'abcx');
});

test('remeasure text when text nodes are changed', t => {
	function Test({add}: {readonly add?: boolean}) {
		return (
			<Box>
				<Text>
					abc
					{add && <Text>x</Text>}
				</Text>
			</Box>
		);
	}

	const stdout = createStdout();

	const {rerender} = render(<Test />, {stdout, debug: true});
	t.is((stdout.write as any).lastCall.args[0], 'abc');

	rerender(<Test add />);
	t.is((stdout.write as any).lastCall.args[0], 'abcx');
});

// See https://github.com/vadimdemedes/ink/issues/743
// Without the fix, the output was ''.
test('text with content "constructor" wraps correctly', t => {
	const output = renderToString(<Text>constructor</Text>);
	t.is(output, 'constructor');
});



================================================
FILE: test/tsconfig.json
================================================
{
	"extends": "../tsconfig.json",
	"include": ["."]
}



================================================
FILE: test/width-height.tsx
================================================
import React from 'react';
import test from 'ava';
import {Box, Text} from '../src/index.js';
import {renderToString} from './helpers/render-to-string.js';

test('set width', t => {
	const output = renderToString(
		<Box>
			<Box width={5}>
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A    B');
});

test('set width in percent', t => {
	const output = renderToString(
		<Box width={10}>
			<Box width="50%">
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A    B');
});

test('set min width', t => {
	const smallerOutput = renderToString(
		<Box>
			<Box minWidth={5}>
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(smallerOutput, 'A    B');

	const largerOutput = renderToString(
		<Box>
			<Box minWidth={2}>
				<Text>AAAAA</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(largerOutput, 'AAAAAB');
});

test.failing('set min width in percent', t => {
	const output = renderToString(
		<Box width={10}>
			<Box minWidth="50%">
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A    B');
});

test('set height', t => {
	const output = renderToString(
		<Box height={4}>
			<Text>A</Text>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'AB\n\n\n');
});

test('set height in percent', t => {
	const output = renderToString(
		<Box height={6} flexDirection="column">
			<Box height="50%">
				<Text>A</Text>
			</Box>
			<Text>B</Text>
		</Box>,
	);

	t.is(output, 'A\n\n\nB\n\n');
});

test('cut text over the set height', t => {
	const output = renderToString(
		<Box height={2}>
			<Text>AAAABBBBCCCC</Text>
		</Box>,
		{columns: 4},
	);

	t.is(output, 'AAAA\nBBBB');
});

test('set min height', t => {
	const smallerOutput = renderToString(
		<Box minHeight={4}>
			<Text>A</Text>
		</Box>,
	);

	t.is(smallerOutput, 'A\n\n\n');

	const largerOutput = renderToString(
		<Box minHeight={2}>
			<Box height={4}>
				<Text>A</Text>
			</Box>
		</Box>,
	);

	t.is(largerOutput, 'A\n\n\n');
});



================================================
FILE: test/fixtures/ci.tsx
================================================
import React from 'react';
import {render, Static, Text} from '../../src/index.js';

type TestState = {
	counter: number;
	items: string[];
};

class Test extends React.Component<Record<string, unknown>, TestState> {
	timer?: NodeJS.Timeout;

	override state: TestState = {
		items: [],
		counter: 0,
	};

	override render() {
		return (
			<>
				<Static items={this.state.items}>
					{item => <Text key={item}>{item}</Text>}
				</Static>

				<Text>Counter: {this.state.counter}</Text>
			</>
		);
	}

	override componentDidMount() {
		const onTimeout = () => {
			if (this.state.counter > 4) {
				return;
			}

			this.setState(prevState => ({
				counter: prevState.counter + 1,
				items: [...prevState.items, `#${prevState.counter + 1}`],
			}));

			this.timer = setTimeout(onTimeout, 100);
		};

		this.timer = setTimeout(onTimeout, 100);
	}

	override componentWillUnmount() {
		clearTimeout(this.timer);
	}
}

render(<Test />);



================================================
FILE: test/fixtures/clear.tsx
================================================
import React from 'react';
import {Box, Text, render} from '../../src/index.js';

function Clear() {
	return (
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>
	);
}

const {clear} = render(<Clear />);
clear();



================================================
FILE: test/fixtures/console.tsx
================================================
import React, {useEffect} from 'react';
import {Text, render} from '../../src/index.js';

function App() {
	useEffect(() => {
		const timer = setTimeout(() => {}, 1000);

		return () => {
			clearTimeout(timer);
		};
	}, []);

	return <Text>Hello World</Text>;
}

const {unmount} = render(<App />);
console.log('First log');
unmount();
console.log('Second log');



================================================
FILE: test/fixtures/erase-with-state-change.tsx
================================================
import process from 'node:process';
import React, {useEffect, useState} from 'react';
import {Box, Text, render} from '../../src/index.js';

function Erase() {
	const [show, setShow] = useState(true);

	useEffect(() => {
		const timer = setTimeout(() => {
			setShow(false);
		});

		return () => {
			clearTimeout(timer);
		};
	}, []);

	return (
		<Box flexDirection="column">
			{show && (
				<>
					<Text>A</Text>
					<Text>B</Text>
					<Text>C</Text>
				</>
			)}
		</Box>
	);
}

process.stdout.rows = Number(process.argv[2]);
render(<Erase />);



================================================
FILE: test/fixtures/erase-with-static.tsx
================================================
import process from 'node:process';
import React from 'react';
import {Static, Box, Text, render} from '../../src/index.js';

function EraseWithStatic() {
	return (
		<>
			<Static items={['A', 'B', 'C']}>
				{item => <Text key={item}>{item}</Text>}
			</Static>

			<Box flexDirection="column">
				<Text>D</Text>
				<Text>E</Text>
				<Text>F</Text>
			</Box>
		</>
	);
}

process.stdout.rows = Number(process.argv[3]);
render(<EraseWithStatic />);



================================================
FILE: test/fixtures/erase.tsx
================================================
import process from 'node:process';
import React from 'react';
import {Box, Text, render} from '../../src/index.js';

function Erase() {
	return (
		<Box flexDirection="column">
			<Text>A</Text>
			<Text>B</Text>
			<Text>C</Text>
		</Box>
	);
}

process.stdout.rows = Number(process.argv[2]);
render(<Erase />);



================================================
FILE: test/fixtures/exit-double-raw-mode.tsx
================================================
import process from 'node:process';
import React from 'react';
import {Text, render, useStdin} from '../../src/index.js';

class ExitDoubleRawMode extends React.Component<{
	setRawMode: (value: boolean) => void;
}> {
	override render() {
		return <Text>Hello World</Text>;
	}

	override componentDidMount() {
		const {setRawMode} = this.props;

		setRawMode(true);

		setTimeout(() => {
			setRawMode(false);
			setRawMode(true);

			// Start the test
			process.stdout.write('s');
		}, 500);
	}
}

function Test() {
	const {setRawMode} = useStdin();

	return <ExitDoubleRawMode setRawMode={setRawMode} />;
}

const {unmount, waitUntilExit} = render(<Test />);

process.stdin.on('data', data => {
	if (String(data) === 'q') {
		unmount();
	}
});

await waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-normally.tsx
================================================
import React from 'react';
import {Text, render} from '../../src/index.js';

const {waitUntilExit} = render(<Text>Hello World</Text>);

await waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-on-exit-with-error.tsx
================================================
import React from 'react';
import {render, Text, useApp} from '../../src/index.js';

class Exit extends React.Component<
	{onExit: (error: Error) => void},
	{counter: number}
> {
	timer?: NodeJS.Timeout;

	override state = {
		counter: 0,
	};

	override render() {
		return <Text>Counter: {this.state.counter}</Text>;
	}

	override componentDidMount() {
		setTimeout(() => {
			this.props.onExit(new Error('errored'));
		}, 500);

		this.timer = setInterval(() => {
			this.setState(prevState => ({
				counter: prevState.counter + 1,
			}));
		}, 100);
	}

	override componentWillUnmount() {
		clearInterval(this.timer);
	}
}

function Test() {
	const {exit} = useApp();
	return <Exit onExit={exit} />;
}

const app = render(<Test />);

try {
	await app.waitUntilExit();
} catch (error: unknown) {
	console.log((error as any).message);
}



================================================
FILE: test/fixtures/exit-on-exit.tsx
================================================
import React from 'react';
import {render, Text, useApp} from '../../src/index.js';

class Exit extends React.Component<
	{onExit: (error: Error) => void},
	{counter: number}
> {
	timer?: NodeJS.Timeout;

	override state = {
		counter: 0,
	};

	override render() {
		return <Text>Counter: {this.state.counter}</Text>;
	}

	override componentDidMount() {
		setTimeout(this.props.onExit, 500);

		this.timer = setInterval(() => {
			this.setState(prevState => ({
				counter: prevState.counter + 1,
			}));
		}, 100);
	}

	override componentWillUnmount() {
		clearInterval(this.timer);
	}
}

function Test() {
	const {exit} = useApp();
	return <Exit onExit={exit} />;
}

const app = render(<Test />);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-on-finish.tsx
================================================
import React from 'react';
import {render, Text} from '../../src/index.js';

class Test extends React.Component<Record<string, unknown>, {counter: number}> {
	timer?: NodeJS.Timeout;

	override state = {
		counter: 0,
	};

	override render() {
		return <Text>Counter: {this.state.counter}</Text>;
	}

	override componentDidMount() {
		const onTimeout = () => {
			if (this.state.counter > 4) {
				return;
			}

			this.setState(prevState => ({
				counter: prevState.counter + 1,
			}));

			this.timer = setTimeout(onTimeout, 100);
		};

		this.timer = setTimeout(onTimeout, 100);
	}

	override componentWillUnmount() {
		clearTimeout(this.timer);
	}
}

render(<Test />);



================================================
FILE: test/fixtures/exit-on-unmount.tsx
================================================
import React from 'react';
import {render, Text} from '../../src/index.js';

class Test extends React.Component<Record<string, unknown>, {counter: number}> {
	timer?: NodeJS.Timeout;

	override state = {
		counter: 0,
	};

	override render() {
		return <Text>Counter: {this.state.counter}</Text>;
	}

	override componentDidMount() {
		this.timer = setInterval(() => {
			this.setState(prevState => ({
				counter: prevState.counter + 1,
			}));
		}, 100);
	}

	override componentWillUnmount() {
		clearInterval(this.timer);
	}
}

const app = render(<Test />);

setTimeout(() => {
	app.unmount();
}, 500);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-raw-on-exit-with-error.tsx
================================================
import React from 'react';
import {render, Text, useApp, useStdin} from '../../src/index.js';

class Exit extends React.Component<{
	onSetRawMode: (value: boolean) => void;
	onExit: (error: Error) => void;
}> {
	override render() {
		return <Text>Hello World</Text>;
	}

	override componentDidMount() {
		this.props.onSetRawMode(true);

		setTimeout(() => {
			this.props.onExit(new Error('errored'));
		}, 500);
	}
}

function Test() {
	const {exit} = useApp();
	const {setRawMode} = useStdin();

	return <Exit onExit={exit} onSetRawMode={setRawMode} />;
}

const app = render(<Test />);

try {
	await app.waitUntilExit();
} catch (error: unknown) {
	console.log((error as any).message);
}



================================================
FILE: test/fixtures/exit-raw-on-exit.tsx
================================================
import React from 'react';
import {render, Text, useApp, useStdin} from '../../src/index.js';

class Exit extends React.Component<{
	onSetRawMode: (value: boolean) => void;
	onExit: (error: Error) => void;
}> {
	override render() {
		return <Text>Hello World</Text>;
	}

	override componentDidMount() {
		this.props.onSetRawMode(true);
		setTimeout(this.props.onExit, 500);
	}
}

function Test() {
	const {exit} = useApp();
	const {setRawMode} = useStdin();

	return <Exit onExit={exit} onSetRawMode={setRawMode} />;
}

const app = render(<Test />);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-raw-on-unmount.tsx
================================================
import React from 'react';
import {render, Text, useStdin} from '../../src/index.js';

class Exit extends React.Component<{
	onSetRawMode: (value: boolean) => void;
}> {
	override render() {
		return <Text>Hello World</Text>;
	}

	override componentDidMount() {
		this.props.onSetRawMode(true);
	}
}

function Test() {
	const {setRawMode} = useStdin();
	return <Exit onSetRawMode={setRawMode} />;
}

const app = render(<Test />);

setTimeout(() => {
	app.unmount();
}, 500);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/exit-with-thrown-error.tsx
================================================
import React from 'react';
import {render} from '../../src/index.js';

const Test = () => {
	throw new Error('errored');
};

const app = render(<Test />);

try {
	await app.waitUntilExit();
} catch (error: unknown) {
	console.log((error as any).message);
}



================================================
FILE: test/fixtures/fullscreen-no-extra-newline.tsx
================================================
import process from 'node:process';
import React, {useEffect} from 'react';
import {Box, Text, render, useApp} from '../../src/index.js';

function Fullscreen() {
	const {exit} = useApp();

	useEffect(() => {
		// Exit after first render to check the output
		const timer = setTimeout(() => {
			exit();
		}, 100);

		return () => {
			clearTimeout(timer);
		};
	}, [exit]);

	// Force the root to occupy exactly terminal rows
	const rows = Number(process.argv[2]) || 5;

	return (
		<Box height={rows} flexDirection="column">
			<Box flexGrow={1}>
				<Text>Full-screen: top</Text>
			</Box>
			<Text>Bottom line (should be usable)</Text>
		</Box>
	);
}

// Set terminal size from argument
process.stdout.rows = Number(process.argv[2]) || 5;

render(<Fullscreen />);



================================================
FILE: test/fixtures/use-input-ctrl-c.tsx
================================================
import React from 'react';
import {render, useInput, useApp} from '../../src/index.js';

function UserInput() {
	const {exit} = useApp();

	useInput((input, key) => {
		if (input === 'c' && key.ctrl) {
			exit();
			return;
		}

		throw new Error('Crash');
	});

	return null;
}

const app = render(<UserInput />, {exitOnCtrlC: false});

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/use-input-multiple.tsx
================================================
import React, {useState, useCallback, useEffect} from 'react';
import {render, useInput, useApp, Text} from '../../src/index.js';

function App() {
	const {exit} = useApp();
	const [input, setInput] = useState('');

	const handleInput = useCallback((input: string) => {
		setInput((previousInput: string) => previousInput + input);
	}, []);

	useInput(handleInput);
	useInput(handleInput, {isActive: false});

	useEffect(() => {
		setTimeout(exit, 1000);
	}, []);

	return <Text>{input}</Text>;
}

const app = render(<App />);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/use-input.tsx
================================================
import process from 'node:process';
import React from 'react';
import {render, useInput, useApp} from '../../src/index.js';

function UserInput({test}: {readonly test: string | undefined}) {
	const {exit} = useApp();

	useInput((input, key) => {
		if (test === 'lowercase' && input === 'q') {
			exit();
			return;
		}

		if (test === 'uppercase' && input === 'Q' && key.shift) {
			exit();
			return;
		}

		if (test === 'uppercase' && input === '\r' && !key.shift) {
			exit();
			return;
		}

		if (test === 'pastedCarriageReturn' && input === '\rtest') {
			exit();
			return;
		}

		if (test === 'pastedTab' && input === '\ttest') {
			exit();
			return;
		}

		if (test === 'escape' && key.escape) {
			exit();
			return;
		}

		if (test === 'ctrl' && input === 'f' && key.ctrl) {
			exit();
			return;
		}

		if (test === 'meta' && input === 'm' && key.meta) {
			exit();
			return;
		}

		if (test === 'upArrow' && key.upArrow && !key.meta) {
			exit();
			return;
		}

		if (test === 'downArrow' && key.downArrow && !key.meta) {
			exit();
			return;
		}

		if (test === 'leftArrow' && key.leftArrow && !key.meta) {
			exit();
			return;
		}

		if (test === 'rightArrow' && key.rightArrow && !key.meta) {
			exit();
			return;
		}

		if (test === 'upArrowMeta' && key.upArrow && key.meta) {
			exit();
			return;
		}

		if (test === 'downArrowMeta' && key.downArrow && key.meta) {
			exit();
			return;
		}

		if (test === 'leftArrowMeta' && key.leftArrow && key.meta) {
			exit();
			return;
		}

		if (test === 'rightArrowMeta' && key.rightArrow && key.meta) {
			exit();
			return;
		}

		if (test === 'upArrowCtrl' && key.upArrow && key.ctrl) {
			exit();
			return;
		}

		if (test === 'downArrowCtrl' && key.downArrow && key.ctrl) {
			exit();
			return;
		}

		if (test === 'leftArrowCtrl' && key.leftArrow && key.ctrl) {
			exit();
			return;
		}

		if (test === 'rightArrowCtrl' && key.rightArrow && key.ctrl) {
			exit();
			return;
		}

		if (test === 'pageDown' && key.pageDown && !key.meta) {
			exit();
			return;
		}

		if (test === 'pageUp' && key.pageUp && !key.meta) {
			exit();
			return;
		}

		if (test === 'tab' && input === '' && key.tab && !key.ctrl) {
			exit();
			return;
		}

		if (test === 'shiftTab' && input === '' && key.tab && key.shift) {
			exit();
			return;
		}

		if (test === 'backspace' && input === '' && key.backspace) {
			exit();
			return;
		}

		if (test === 'delete' && input === '' && key.delete) {
			exit();
			return;
		}

		if (test === 'remove' && input === '' && key.delete) {
			exit();
			return;
		}

		throw new Error('Crash');
	});

	return null;
}

const app = render(<UserInput test={process.argv[2]} />);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/fixtures/use-stdout.tsx
================================================
import React, {useEffect} from 'react';
import {render, useStdout, Text} from '../../src/index.js';

function WriteToStdout() {
	const {write} = useStdout();

	useEffect(() => {
		write('Hello from Ink to stdout\n');
	}, []);

	return <Text>Hello World</Text>;
}

const app = render(<WriteToStdout />);

await app.waitUntilExit();
console.log('exited');



================================================
FILE: test/helpers/create-stdout.ts
================================================
import EventEmitter from 'node:events';
import {spy} from 'sinon';

// Fake process.stdout
type FakeStdout = {
	get: () => string;
} & NodeJS.WriteStream;

const createStdout = (columns?: number): FakeStdout => {
	const stdout = new EventEmitter() as unknown as FakeStdout;
	stdout.columns = columns ?? 100;

	const write = spy();
	stdout.write = write;

	stdout.get = () => write.lastCall.args[0] as string;

	return stdout;
};

export default createStdout;



================================================
FILE: test/helpers/force-colors.ts
================================================
import chalk, {supportsColor} from 'chalk';

// Force chalk to output colors even in non-TTY environments for testing
export const enableTestColors = () => {
	// Force chalk to output colors
	chalk.level = 3; // Full color support (16m colors)
};

export const disableTestColors = () => {
	// Restore chalk's automatic detection
	chalk.level = supportsColor ? supportsColor.level : 0;
};



================================================
FILE: test/helpers/render-to-string.ts
================================================
import {render} from '../../src/index.js';
import createStdout from './create-stdout.js';

export const renderToString: (
	node: React.JSX.Element,
	options?: {columns?: number; isScreenReaderEnabled?: boolean},
) => string = (node, options) => {
	const stdout = createStdout(options?.columns ?? 100);

	render(node, {
		stdout,
		debug: true,
		isScreenReaderEnabled: options?.isScreenReaderEnabled,
	});

	const output = stdout.get();
	return output;
};



================================================
FILE: test/helpers/run.ts
================================================
import process from 'node:process';
import {createRequire} from 'node:module';
import path from 'node:path';
import url from 'node:url';

const require = createRequire(import.meta.url);

// eslint-disable-next-line @typescript-eslint/consistent-type-imports
const {spawn} = require('node-pty') as typeof import('node-pty');

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

type Run = (
	fixture: string,
	props?: {env?: Record<string, string>; columns?: number},
) => Promise<string>;

export const run: Run = async (fixture, props) => {
	const env: Record<string, string> = {
		...(process.env as Record<string, string>),
		// eslint-disable-next-line @typescript-eslint/naming-convention
		CI: 'false',
		...props?.env,
		// eslint-disable-next-line @typescript-eslint/naming-convention
		NODE_NO_WARNINGS: '1',
	};

	return new Promise<string>((resolve, reject) => {
		const term = spawn(
			'node',
			[
				'--loader=ts-node/esm',
				path.join(__dirname, `/../fixtures/${fixture}.tsx`),
			],
			{
				name: 'xterm-color',
				cols: typeof props?.columns === 'number' ? props.columns : 100,
				cwd: __dirname,
				env,
			},
		);

		let output = '';

		term.onData(data => {
			output += data;
		});

		term.onExit(({exitCode}) => {
			if (exitCode === 0) {
				resolve(output);
				return;
			}

			reject(new Error(`Process exited with a non-zero code: ${exitCode}`));
		});
	});
};



================================================
FILE: .github/workflows/test.yml
================================================
name: test
on: [push, pull_request]
jobs:
  test:
    name: Node.js ${{ matrix.node_version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node_version:
          - 20
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ matrix.node_version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
      - run: npm install
      - run: npm test -- --serial
        env:
          FORCE_COLOR: true
          CI: false


